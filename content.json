{"meta":{"title":"Frank","subtitle":null,"description":null,"author":"Frank C.","url":"https://crepe.coding.me/Crepeblog"},"pages":[{"title":"我的朋友们","date":"2019-01-05T05:14:22.876Z","updated":"2019-01-01T05:13:42.000Z","comments":true,"path":"friends/index.html","permalink":"https://crepe.coding.me/Crepeblog/friends/index.html","excerpt":"","text":""},{"title":"精选项目","date":"2019-01-05T05:14:22.876Z","updated":"2018-12-31T02:01:10.000Z","comments":true,"path":"projects/index.html","permalink":"https://crepe.coding.me/Crepeblog/projects/index.html","excerpt":"","text":"啊，这里居然是空的"}],"posts":[{"title":"春节快乐","slug":"春节快乐","date":"2019-02-04T12:38:56.000Z","updated":"2019-02-04T12:56:19.064Z","comments":true,"path":"2019/02/04/春节快乐/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2019/02/04/春节快乐/","excerpt":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看","text":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看 献上笔者绘制的Peppa Pig(社会猪佩奇) 送上猪年祝福语 春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。 朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！ 猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！ 除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！ 春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。 猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！ 一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！ 春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！ 绘制佩奇使用的是PS的钢笔","categories":[],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://crepe.coding.me/Crepeblog/tags/节日祝福/"}]},{"title":"HTML (一)","slug":"HTML (一)","date":"2019-01-25T13:36:08.000Z","updated":"2019-01-27T15:46:11.720Z","comments":true,"path":"2019/01/25/HTML (一)/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2019/01/25/HTML (一)/","excerpt":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。","text":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。 简介HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。现如今，HTML已经是程序员必须掌握的一项基本功。 HTML发展史HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。 HTML 2.0——1995年11月，RFC 1866发布 HTML 3.2——1997年1月14日，W3C发布推荐标准HTML 4.0——1997年12月18日，W3C发布推荐标准 HTML 4.01——1999年12月24日，W3C发布推荐标准*HTML 5——2014年10月28日，W3C发布推荐标准 HTML5编辑规范 文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg 浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车 标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。 必须使用半角而不是全角字符 HTML注释&lt;!--注释内容--&gt;的内容不给予显示。 这是笔者写的较为详细的一个入门页面HTML入门·一","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://crepe.coding.me/Crepeblog/tags/HTML/"}]},{"title":"PowerShell (一)","slug":"PowerShell (一)","date":"2019-01-17T11:48:41.000Z","updated":"2019-01-17T15:09:12.711Z","comments":true,"path":"2019/01/17/PowerShell (一)/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2019/01/17/PowerShell (一)/","excerpt":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。","text":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。 介绍PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，PowerShell需要.NET环境的支持，借助 .NET Framework平台强大的类库，几乎让一切都成为可能。微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。 受众Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。 特点通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。PowerShell以 .NET Framework为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。PowerShell推出了一个功能强大的命令叫做cmdlet,所有的cmdlet命令都遵循动词-名词这样语法结构。如Get-Command, Get-Process等，即使从来没有接触过PowerShell，也很容易能够明白命令的作用。如Get-Process命令的意思就是获取所有的进程。 新的脚本语言由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。 PS1文件一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。 执行权限为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（Restricted），意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略： Get-ExecutionPolicy你可以选择使用的执行策略有： Restricted -脚本不能运行。 RemoteSigned - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 AllSigned – 仅当脚本由受信任的发布者签名才能运行。 Unrestricted –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。 你可以使用下面的cmdlet命令设置PowerShell的执行策略：1Set-ExecutionPolicy &lt;policy name&gt; 运行脚本如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，但这个古老的方法现在却不能适用于PowerShell可执行脚本了。如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，例如，假设你要运行一个名为a.ps1的脚本，你可以键入：C:\\Scripts\\aps1最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符后键入脚本文件名即可运行，如：.\\a.ps1 注意前面需要加上.\\，这和Linux下执行Shell脚本的方法如出一辙。 管道管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（|）连接即可。为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，可以使用Get-Process cmdlet命令获得进程列表，但默认情况下列表不会排序，如果将这个cmdlet命令的输出用管道输送给Sort-Object ID命令，进程列表将会按进程ID号进行排序，如： 1Get-Process | Sort-Object ID 变量虽然可以使用管道将一个命令的输出输送给另一个命令，但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：$a = Get-Process在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，例如，键入$a便可在屏幕上打印变量的内容。你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令： 1$a = (Get-Process | Sort-Object ID) @符号通过使用@符号，你可以将列表内容转换成一个数组，例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：$procs = @{name=&quot;explorer&quot;,&quot;svchost&quot;}使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，例如，下面的代码将在我前面定义的变量上运行Get-Process cmdlet命令： 1Get-Process @procsWindows 将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的@符号，而不是常见的$符号。 SplitSplit操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到： 1\"This is a test\" -split \" \" 拆分后的结果如下：This is a test Join就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成： 1\"Brien\",\"Posey\" -join \" \" 命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。 断点运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令： 1234567New-PSBreakpoint -Script C:\\Scripts\\a.ps1 -Line 10#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：New-PSBreakpoint -Script C:\\scripts\\a.ps1 -variables a #注意，在变量名后并没有包括美元符号。#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。 Step调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用Step-Into cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用Step-Out cmdlet命令即可，但需要注意的是，使用Step-Out cmdlet命令后，断点仍然有效。顺便说一句，如果你的脚本使用了函数，你可能对Step-Out cmdlet更感兴趣，Step-Out 的工作方式和Step-Into 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。 因此PowerShell实际是一门独立的脚本语言了PowerShell能干什么？PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。 PowerShell能做下面这些事: .NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint, Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS, Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications. 基本上所有的微软产品都提供PowerShell接口。 1、管理进程前面已经提过管理系统进程的命令，管理进程常用命令就是get-process和stop-process，get-process获取进程之后可以直接用管道发送给stop-process结束进程。比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。1get-process -Name notepad | stop-process 2、处理文件和文件夹PowerShell使用Get-ChildItem获取文件夹中直接包含的所有项，它有系统内置别名dir和ls，使用CMD和BASH的用户均可以轻松上手。如果想查看C:中的文件夹和文件，直接使用dir c:，PowerShell立刻就会列出C:中的文件和文件夹。其它处理文件和文件夹的命令有Copy-Item、New-Item、Remove-Item等，具体用法可以使用get-help然后跟命令名称即可查询。 3、处理系统服务可以像管理进程一样管理系统服务， Get-Service命令获取服务列表， Stop-Service命令停止服务， Start-Service命令启动服务， Suspend-Service命令挂起服务， Restart-Service命令重启服务， Set-Service服务设置服务属性。如果想一次性启动已经停止的服务，可以使用以下命令：1get-service | where-object &#123;$_.Status -eq \"Stopped\"&#125; -exclude 下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。wisvc | start-service 4、处理注册表PowerShell可以非常方便的处理注册表项目，与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。由于注册表对系统非常重要，错误处理注册表也许会导致系统出问题，处理注册表，特别是删除注册表项目要非常小心，最好能在处理注册表项目之前先备份要处理的项目。没有管理员权限也能处理部分注册表项目，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。 5、处理其它任务PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。 6、编写脚本程序借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。 一个有趣的例子这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。 12345678910111213141516171819202122232425# 创建新的excel com对象$objExcel = New-Object -comobject Excel.Application$objExcel.Visible = $True$objWorkbook = $objExcel.Workbooks.Add()$objWorksheet = $objWorkbook.Worksheets.Item(1)# 把信息写入excel$i = 0$first10 = (ps | sort ws -Descending | select -first 10)$first10 | foreach -Process &#123;$i++; $objWorksheet.Cells.Item($i,1) = $_.name; $objWorksheet.Cells.Item($i,2) = $_.ws&#125;$otherMem = (ps | measure ws -s).Sum - ($first10 | measure ws -s).Sum$objWorksheet.Cells.Item(11,1) = \"Others\"; $objWorksheet.Cells.Item(11,2) = $otherMem# 画饼图$objCharts = $objWorksheet.ChartObjects()$objChart = $objCharts.Add(0, 0, 500, 300)$objChart.Chart.SetSourceData($objWorksheet.range(\"A1:B11\"), 2)$objChart.Chart.ChartType = 70$objChart.Chart.ApplyDataLabels(5)#暂停pause$objExcel.Quit()$objExcel = $null[GC]::Collect() 执行结果:","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://crepe.coding.me/Crepeblog/tags/PowerShell/"}]},{"title":"元旦快乐","slug":"元旦快乐","date":"2018-12-31T16:12:12.000Z","updated":"2019-02-04T12:56:17.044Z","comments":true,"path":"2019/01/01/元旦快乐/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2019/01/01/元旦快乐/","excerpt":"2019元旦快乐","text":"2019元旦快乐 相逢是首悠扬的歌，相识是杯醇香的酒，相处是那南飞的雁，相知是根古老的藤。健康是最佳的礼物，知足是最大的财富，信心是最可贵的品德，关心是最真挚的问候，牵挂是最无私的思念，祝福是最美好的话语！ 在此献上最美好的祝福祝各位朋友们2019年新年快乐！平安幸福！","categories":[],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://crepe.coding.me/Crepeblog/tags/节日祝福/"}]},{"title":"面向对象的程序设计","slug":"面向对象的程序设计","date":"2018-12-30T07:06:15.000Z","updated":"2018-12-31T00:52:58.000Z","comments":true,"path":"2018/12/30/面向对象的程序设计/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2018/12/30/面向对象的程序设计/","excerpt":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。","text":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。 特点面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。 发展面向对象是在结构化设计方法出现很多问题的情况下应运而生的。 结构化设计方法求解问题的基本策略是从功能的角度审视问题域。它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。 1. 审视问题域的视角 在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。 2. 抽象级别 抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。 3. 封装体 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。 4. 可重用性 可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。 上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。 面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地适应了潮流。面向对象程序设计的思想也使事件处理式的程序设计更加广泛被应用 抽象的示例假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，首先想到的是开一个结构体，然后定义几个变量: 12345678struct Sheep&#123; int age; double height; double weight;&#125;;Sheep Jeff; //定义一只叫Jeff的羊 很容易，现在Jeff要跑，怎么办？于是就用一个run函数，把Jeff作为一个参数传递来实现: 123456void run(Sheep sheep)&#123; /* code */&#125;run(Jeff); 也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？ 这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；这样，所有的羊都有了一种叫跑步的方法，就方便多了: 123456789101112131415161718class Sheep &#123;public: void run(string method=\"default\"); void mie();//咩private: int age; double height,weight;&#125;;//定义一个Sheep类Sheep Jeff;Jeff.run(); //Jeff使用默认的方法跑步Sheep YangDaXia;YangDaXia.run(\"onFoot\"); //羊大侠站着跑Sheep XiYangYang;XiYangYang.run(\"shoes\"); //喜羊羊穿鞋跑","categories":[],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://crepe.coding.me/Crepeblog/tags/面向对象/"},{"name":"C/C++","slug":"C-C","permalink":"https://crepe.coding.me/Crepeblog/tags/C-C/"}]},{"title":"The first one","slug":"The-first-one","date":"2018-12-30T03:44:32.000Z","updated":"2019-01-01T05:36:07.000Z","comments":true,"path":"2018/12/30/The-first-one/","link":"","permalink":"https://crepe.coding.me/Crepeblog/2018/12/30/The-first-one/","excerpt":"测试用页面","text":"测试用页面 第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1][^1]: 这是脚注 这是1级标题这是斜体这是加粗这是斜体加粗 这是删除 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello,world!\"; return 0; //这是代码段&#125; 这是2级标题这是代码块 这是3级标题 这是引述 这是引述嵌套 这是4级标题这是百度一下 -[x] 选项一-[ ] 选项二-[ ] 选项三 这是5级标题 这是无序列表 这是无序列表 这是无序列表 这是有序列表 这是有序列表 这是有序列表","categories":[],"tags":[]}]}