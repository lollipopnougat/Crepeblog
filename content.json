{"meta":{"title":"LNP","subtitle":null,"description":null,"author":"LNP.","url":"https://lollipopnougat.github.io/Crepeblog","root":"/Crepeblog/"},"pages":[{"title":"精选项目","date":"2020-02-25T04:33:50.441Z","updated":"2020-02-25T04:33:50.441Z","comments":true,"path":"projects/index.html","permalink":"https://lollipopnougat.github.io/Crepeblog/projects/index.html","excerpt":"","text":"自己觉得还可以的项目 算法学习项目地址 明日方舟模拟寻访项目地址 网络安全协会主页项目地址 看起来没有多少项目的亚子"},{"title":"我的朋友们","date":"2020-02-25T06:17:10.561Z","updated":"2020-02-25T06:17:10.561Z","comments":true,"path":"friends/index.html","permalink":"https://lollipopnougat.github.io/Crepeblog/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"肺炎疫情信息的获取","slug":"肺炎疫情信息的获取","date":"2020-02-05T02:47:53.000Z","updated":"2020-02-28T15:01:02.133Z","comments":true,"path":"2020/02/05/肺炎疫情信息的获取/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2020/02/05/肺炎疫情信息的获取/","excerpt":"python 爬虫相关也算是练习一下好久没写的爬虫了","text":"python 爬虫相关也算是练习一下好久没写的爬虫了 最近病毒肆虐，丁香园为了方便大众得知最新消息，开设了一个网页,可以从中得知当前的最新感染数据信息，笔者在浏览此页面后看到数据是以 json 格式送到浏览器的，觉得不妨写一个爬虫获取数据写入文件来进行统计… 爬取到的网页关键数据(全国)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script id=\"getStatisticsService\"&gt; try &#123; window.getStatisticsService = &#123; id: 1, createTime: 1579537899000, modifyTime: 1580795061000, infectSource: '该字段已替换为说明2', passWay: '该字段已替换为说明3', imgUrl: 'https://img1.dxycdn.com/2020/0201/450/3394153392393266839-135.png', dailyPic: 'https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png,https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png,https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png,https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png,https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png', dailyPics: [ 'https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png', 'https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png', 'https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png', 'https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png', 'https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png' ], summary: '', deleted: false, countRemark: '', confirmedCount: 20471, suspectedCount: 23214, curedCount: 657, deadCount: 426, seriousCount: 2788, suspectedIncr: 5072, confirmedIncr: 3235, curedIncr: 182, deadIncr: 65, seriousIncr: 492, virus: '该字段已替换为说明1', remark1: '易感人群：人群普遍易感。老年人及有基础疾病者感染后病情较重，儿童及婴幼儿也有发病', remark2: '潜伏期：一般为 3～7 天，最长不超过 14 天，潜伏期内存在传染性', remark3: '宿主：野生动物，可能为中华菊头蝠', remark4: '', remark5: '', note1: '病毒：新型冠状病毒 2019-nCoV', note2: '传染源：新型冠状病毒感染的肺炎患者', note3: '传播途径：经呼吸道飞沫传播，亦可通过接触传播，存在粪-口传播可能性', generalRemark: '疑似病例数来自国家卫健委数据，目前为全国数据，未分省市自治区等', abroadRemark: '', marquee: [] &#125; &#125; catch (e) &#123;&#125;&lt;/script&gt; 爬取到的网页关键数据(各省，局部)123456789101112131415161718192021222324252627try &#123; window.getAreaStat = [ &#123; provinceName: '湖北省', provinceShortName: '湖北', confirmedCount: 13522, suspectedCount: 0, curedCount: 398, deadCount: 414, comment: '待明确地区，治愈 96', locationId: 420000, cities: [ &#123; cityName: '武汉', confirmedCount: 6384, suspectedCount: 0, curedCount: 307, deadCount: 313, locationId: 420100 &#125;, &#123; // 以下省略n个城市 &#125; ] &#125; ]&#125; 如何从爬取的字符串中获取数据经过一番分析，最终使用了正则和 BS 库获取了 json 字符串，剩下的就很好处理了。 123456789pat1 = re.compile('(\\[[^\\]]+?\\])')#原本写的是 pat2 = re.compile('(\\&#123;[^\\&#125;\\&#123;]+?\\&#125;)') 但丁香园发布了一条特殊格式的数据后不能用了，于是就换成了下面那个pat2 = re.compile('=\\s?(\\&#123;.+)\\&#125;catch')dat1 = str(soup.findAll(id='getListByCountryTypeService1')[0].string)dat2 = str(soup.findAll(id='getStatisticsService')[0].string)# 各省st1 = pat1.findall(dat1)[0]# 全国st2 = pat2.findall(dat2)[0] 附赠一个可以显示目前各省累计确诊人数占全国比例的爬虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requests as reqfrom bs4 import BeautifulSoup as bsimport reimport jsonimport csvimport matplotlib.pyplot as pltimport matplotliburl = 'https://ncov.dxy.cn/ncovh5/view/pneumonia_peopleapp'header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36'&#125;pat1 = re.compile('(\\[[^\\]]+?\\])')pat2 = re.compile('=\\s?(\\&#123;.+)\\&#125;catch')def task(): res = req.get(url=url, headers=header) print(res.status_code) res.encoding = res.apparent_encoding soup = bs(res.text, 'html.parser') dat1 = str(soup.findAll(id='getListByCountryTypeService1')[0].string) dat2 = str(soup.findAll(id='getStatisticsService')[0].string) st1 = pat1.findall(dat1)[0] st2 = pat2.findall(dat2)[0] js = json.loads(st1) al = json.loads(st2) prov_list = [] conf_list = [] for i in js: print('%s 确诊数： %d， 治愈数： %d， 死亡数: %d' % (i['provinceName'], i['confirmedCount'], i['curedCount'], i['deadCount'])) prov_list.append(i['provinceName']) conf_list.append(i['confirmedCount']) print('全国确诊： %d， 疑似数： %d， 治愈数： %d， 死亡数： %d， 重症数： %d' % (al['confirmedCount'], al['suspectedCount'], al['curedCount'], al['deadCount'], al['seriousCount'])) # 调用 matplotlib 准备绘图 font = &#123;'family': 'MicroSoft YaHei', 'weight': 'light', 'size': 10&#125; matplotlib.rc(\"font\", **font) fig = plt.figure(figsize=(10, 9), dpi=80) fig.canvas.set_window_title('全国各省感染人数占比') plt.axes(aspect=1) # 饼图 plt.pie(x=conf_list, labels=prov_list, autopct='%3.1f %%', pctdistance=1.2, labeldistance=1.0) plt.title('全国各省感染人数占比') plt.legend() plt.show() input('任意键继续')if __name__ == \"__main__\": task() 后记完成整个脚本以后配置一下计划任务，再添加一个每一小时获取一次写入文件功能，省了不少事…其实还可以通过异步维护一个计时器，每隔一段时间运行一次(好像单线程就是用 sleep 也可以吧，嘛不管了)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/爬虫/"}]},{"title":"最近忙的很","slug":"最近忙的很","date":"2019-12-03T13:10:21.000Z","updated":"2020-02-25T05:44:15.313Z","comments":true,"path":"2019/12/03/最近忙的很/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/12/03/最近忙的很/","excerpt":"最近事还挺多的…也没顾的上更新博客","text":"最近事还挺多的…也没顾的上更新博客 等到课近期的设完成大概就有时间了吧…今天先鸽了，，，咕咕咕","categories":[],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/吐槽/"}]},{"title":"网络安全协会网站的搭建(一)","slug":"网络安全协会网站的搭建(1)","date":"2019-09-06T15:20:37.000Z","updated":"2020-02-25T05:41:17.893Z","comments":true,"path":"2019/09/06/网络安全协会网站的搭建(1)/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/09/06/网络安全协会网站的搭建(1)/","excerpt":"网络安全协会网站的搭建一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊特别是看了ACM协会的网站之后，更加坚定了开发的想法所以这个项目就出现了 网站预览","text":"网络安全协会网站的搭建一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊特别是看了ACM协会的网站之后，更加坚定了开发的想法所以这个项目就出现了 网站预览 Vue.js 与 Node.js Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 早就在关注尤雨溪大佬和他的Vue.js项目。 今年年初曾尝试搞了一个demo，结果最后搞的一头雾水，也没弄懂…最终结果就是弃了… 直到今年5月份我准备做数据库课设，才算稍微系统地学习了一下 Node.js，用 Express 熟悉了一下 Node 的项目结构和使用 npm 的方法，顺便提高了js的开发能力。我也学到了 js 的异步回调什么的，还有编写 HTML 和 CSS 的熟练度也得到了少许提高，暑假时又学习了一部分 TypeScript 和 ES6 的语法，勉强算是做了较多的铺垫。 这两天重新看 vue 的项目的时候终于明白那都是什么东西了，有点 Express 的感觉，但是 router 竟然可以 build 成静态的，默认采用的是 Hash 方式，一个网站可以做成单页的，有趣啊！ 于是9月1日建立了项目仓库，9月3日提交了研究了两天的结果(一个 Header )，因为将来要放到新GitHub账号上，build出来的静态文件有开 Http 服务的要求，因此我专门开了我GitHub的托管根目录做预览，这周前前后后一共提交了7次，之后就正式迁移到 chdans.github.io 了，我修改了结构，我build好的项目提交到我fork出来的 chdans 创建的那个静态页项目下，然后再新建 Pull Request，提交到 chdans，再由 chdans来 Merge 请求，这就是一次完整的更新。 不得不说element ui做的真的既简介又漂亮，原版的配色我是很喜欢的，我一度把协会的宣传海报也采用相同配色，如图 之后会详细解释这个网站项目 今天就写这么多，明天还要迎新，7点就要去…","categories":[],"tags":[{"name":"网站搭建","slug":"网站搭建","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/网站搭建/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/Vue-js/"},{"name":"网络安全协会","slug":"网络安全协会","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/网络安全协会/"}]},{"title":"PowerShell入门指南(3)","slug":"PowerShell入门指南(3)","date":"2019-07-29T01:56:12.000Z","updated":"2020-02-25T05:39:10.655Z","comments":true,"path":"2019/07/29/PowerShell入门指南(3)/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/07/29/PowerShell入门指南(3)/","excerpt":"PowerShell入门指南(三)·一门新的编程语言 作为独立的编程语言作为一门独立的语言来说，PowerShell 是非常地Powerful，我们先来了解一下它的特点:","text":"PowerShell入门指南(三)·一门新的编程语言 作为独立的编程语言作为一门独立的语言来说，PowerShell 是非常地Powerful，我们先来了解一下它的特点: 特点 破天荒的方便诸如存储计算中 GB， MB， KB 单位等；数组声明中的 1..n 和下标为 -1 的处理；还有所见即所得，通俗易懂的动词+名词结构的Cmdlet(PowerShell命令的称呼)。还有自带的文档支持也很是丰富，只要熟练掌握 Get-Help 命令，其他命令的用法均可通过 Get-Help 查到 面向对象良心啊，这个语言竟然是面向对象的与面向过程相比，面向对象更方便更容易描述现实世界，也算赶上了时髦。 依托 .NET正所谓大树下面好乘凉，PowerShell 绑上 .NET 这个大款了，借助 .NET 平台强大的类库，几乎让一切都成为可能。 强大的兼容性完全兼容 Windows 平台上其它调用，如可执行文件(exe)，批处理bat/cmd和VBscript等, 在 Linux 和 macOS 上也能很好地工作。 基于平台的可扩展性微软有个优点，与应用相比，它更喜欢做平台。PowerShell 早已变成一个平台，在 PowerShell 刚发布的第二年，微软的 System Center Operations Manager 和 SharePoint 就提供了针对该平台的组件，后来的活动目录，Hyper-V，Windows Azure，Office 365就更不用说了。除了微软，亚马逊的云平台管理，Dell的out-of-hand 管理，也都提供了基于 PowerShell 的管理组件。PowerShell 俨然变成了一个标准，变成了一个规范。 使用Get-Help 快速入门下面用一个简单例子说明如何Get-Help，设想这样一个场景：你想通过命令行查看所有进程，你第一个反应应该是用一个跟Process相关的命令来达到此目的，所以你可以会尝试执行： 1234567891011Get-Command *Process#结果CommandType Name Version Source----------- ---- ------- ------Cmdlet Debug-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Enter-PSHostProcess 3.0.0.0 Microsoft.PowerShell.CoreCmdlet Exit-PSHostProcess 3.0.0.0 Microsoft.PowerShell.CoreCmdlet Get-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Start-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Stop-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Wait-Process 3.1.0.0 Microsoft.PowerShell.Management 得知处理进程的命令有这些然后再用 Get-Help Get-Process -full 就能得到 Get-Process 的详细用法以及使用范例 基本语法背景PowerShell 是一个强类型(变量一旦定义，其本身类型不可改变就是强类型，反之就是弱类型)的动态脚本语言，支持面向对象，支持调用系统API和 .NET 库。受到了 Python, Ksh, Perl, C#, CL, DCL, SQL, Tcl, Tk, Chef, Puppet 等语言的影响，结合了以上语言的部分特性。 PowerShell 代码的外观和操作方式与C#的相似程度最高，不过也有它自己的特色。 关于空白字符与 Python 等语言不同，PowerShell 的解释器不会考虑代码中的空格或制表符(这些字符统称空白字符)。这样一来，格式化代码就有很大的自由度，但是遵循某些规则将有助于提高代码的可读性。 代码块和代码基本结构PowerShell 代码由一系列语句构成，每条语句可以使用一个分号结束，当然也可以不写。按照习惯是不写分号的，因此要用换行来区分不同的语句，如果必须写到一行中，那就在每一句后加个分号。 和C语系的大多数语言类似，PowerShell 是一种块结构的语言，这些块用 { 和 } 来界定，代码块可以包含任意多条语句，或者不包含任何语句，下面的示例还使用了缩进格式，这样能大大提高可读性，实际上编译器会自带缩进代码。一般情况下，每个代码块都有自己的缩进级别，代码块之间还能嵌套。 123456789&#123; &lt;#代码行1#&gt; &lt;#代码行2#&gt; &#123; &lt;#代码行3#&gt; &lt;#代码行4#&gt; &#125; &lt;#代码行5#&gt;;&lt;#代码行6#&gt;;&#125; 当然 PowerShell 的缩进不是强制的。 在 PowerShell 代码中，另一种常见的语句是注释，注释并不是能执行的语句，而是对代码的描述说明性文本。当代码运行时，解释器会忽略这些内容。代码最好有注释，特别是处理较复杂的工作时，注释可以为正在进行的操作添加提示，例如“这行代码要求用户输入一个字符”、“此段代码是 LNP 编写的”。PowerShell 有两种添加注释方法 行注释: # 块注释: &lt;# 和 #&gt; 1234567891011#这是一行注释&lt;#这是注释块123ABC#&gt;ls #列出当前目录下的文件和文件夹，是Get-ChildItem的别名#注意下面语句会产生错误&lt;#块注释由\"#&gt;\"结尾#&gt; 第一个 #&gt; 后面的部分会被认为是 PowerShell 代码，因此出现错误。 还有特别的注意一点，PowerShell 代码是不区分大小写的，因此只要拼写正确的命令(或变量)，而无需关心大小写即可执行，不过最好还是有一定规范。 PowerShell 脚本的基本结构PowerShell 像 Python 一样，允许使用控制台直接输入命令进行交互，也可以事先把代码写入一个文件再作为脚本运行。一个 PowerShell 脚本仅仅是一个包含 PowerShell 代码的文本文件。如果这个文本文件执行， PowerShell 解释器会逐行解释并执行它的的语句。PowerShell 脚本有点像以前 CMD 控制台上的批处理文件。可以通过非常简单的文本编辑工具创建 PowerShell 脚本。 PowerShell脚本文件的扩展名是 .ps1 执行策略限制PowerShell 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于PowerShell的执行策略。 1234567PS E:&gt; ./MyScript.ps1无法加载文件 E:MyScript.ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 \"get-help about_signing\"。所在位置 行:1 字符: 15+ .MyScript.ps1 &lt; &lt;&lt;&lt; + CategoryInfo : NotSpecified: (:) [], PSSecurityException + FullyQualifiedErrorId : RuntimeException 只有管理员才有权限更改这个策略。非管理员会报错。 查看脚本执行策略，可以通过在 PowerShell 控制台直接输入:Get-ExecutionPolicy更改脚本执行策略，可以管理员启动PowerShell，在控制台输入:Set-ExecutionPolicy &lt;策略&gt;策略|解释-|-Unrestricted|权限最高，可以不受限制执行任何脚本。Default|为Powershell默认的策略，即RestrictedRestricted|不允许任何脚本执行AllSigned|所有脚本都必须经过签名才能在运行RemoteSigned|本地脚本无限制，但是对来自网络的脚本必须经过签名 如果要使用脚本功能又要兼顾安全性，我们就选择RemoteSigned即在以管理员身份允许的 PowerShell 输入Set-ExecutionPolicy RemoteSigned 123执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies帮助主题中所述的安全风险。是否要更改执行策略?[Y] 是(Y) [N] 否(N) [S] 挂起(S) [?] 帮助 (默认值为“Y”): y 运行 PowerShell 脚本当您的脚本编写成功后您可能第一次会像下面的方式运行它，也就是只输入脚本的文件名，会报错。 1234567891011PS E:&gt; MyScript.ps1无法将“MyScript.ps1”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。所在位置 行:1 字符: 13+ MyScript.ps1 &lt; &lt;&lt;&lt; + CategoryInfo : ObjectNotFound: (MyScript.ps1:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundExceptionSuggestion [3,General]: 未找到命令 MyScript.ps1，但它确实存在于当前位置。Windows PowerShell 默认情况下不从当前位置加载命令。如果信任此命令，请改为键入 \"./MyScript.ps1\"。有关更多详细信息，请参阅 \"get-help about_Command_Precedence\"。 解决办法很简单，如果脚本在当前工作目录，请在脚本文件明前添加./，或者使用绝对路径。 12345678910111213PS E:&gt; .\\MyScript.ps12019年3月27日 18:33:03C:\\Program Files\\Common Filesfiles count20PS E:&gt; E:MyScript.ps12019年3月27日 18:33:11C:\\Program Files\\Common Filesfiles count20 通过重定向创建脚本如果想要执行的脚本不是很长，我们甚至可以直接在控制台中要执行的语句重定向给一个脚本文件。 123PS E:&gt; '\"Hello,World!\"' &gt; MyScript.ps1PS E:&gt; ./MyScript.ps1Hello,World! 这样有个缺点，就是您的代码必须放在闭合的引号中。这样的书写方式一旦在脚本内部也有引号时，是一件很痛苦的事。甚至您还可能希望在脚本中换行。下面的Here-strings例子不错，也就是将脚本文件通过@&#39; &#39;@闭合起来。 12345678910111213141516PS E:&gt; @'&gt;&gt; Get-Date&gt;&gt; $Env:CommonProgramFiles&gt;&gt; #Script End&gt;&gt; \"files count\"&gt;&gt; (ls).Count&gt;&gt; #Script Really End&gt;&gt;&gt;&gt; '@ &gt; myscript.ps1&gt;&gt;PS E:&gt; .MyScript.ps12019年3月27日 18:15:10C:\\Program Files\\Common Filesfiles count20 Here-String以 @&#39;开头，以&#39;@结束.任何文本都可以存放在里面，哪怕是一些特殊字符，空号，白空格。但是如果您不小心将单引号写成了双引号，PowerShell 将会把里面的变量进行解析。 通过编辑器创建脚本其实最方便的还是使用文本编辑器直接编写代码，保存成PS1文件，右键即可执行。这里推荐使用Visual Studio Code(以下简称VSC)，VSC提供了PS1的自动补全(安装插件)、语法高亮、自动缩进、格式化代码、断点调试等功能。 变量变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。PowerShell 的变量定义非常方便。我们可以用 $变量名=初值 的方法定义变量，解释器会根据所赋的初值判断变量类型，类似于C#的 var 关键字或C++11中的 auto 关键字PowerShell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$.创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外:单引号中的字符串不会识别和处理变量名。 选择变量名在 PowerShell 中变量名均是以美元符 $ 开始，剩余字符可以是数字、字母、下划线的任意字符，并且PowerShell变量名也对大小写不敏感（$a 和 $A 是同一个变量)。某些特殊的字符(比如$等)在 PowerShell 中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 123PS C:/&gt; $&#123;\"I\"like $&#125;=5.1PS C:/&gt; $&#123;\"I\"like $&#125;5.1 不能定义和保留变量名称相同的变量使用ls variable: 列出当前使用的所有变量，刚启动的 PowerShell 执行此命令能看到 PowerShell 的所有自动化变量(一旦打开 Powershell 就会自动加载的变量，后面将会详细解释这些变量的作用) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Name Value---- -----$? True^args &#123;&#125;ConfirmPreference HighConsoleFileNameDebugPreference SilentlyContinueError &#123;&#125;ErrorActionPreference ContinueErrorView NormalViewExecutionContext System.Management.Automation.EngineIntrinsicsfalse FalseFormatEnumerationLimit 4HOME C:\\Users\\aaaaaHost System.Management.Automation.Internal.Host.InternalHostInformationPreference SilentlyContinueinput System.Collections.ArrayList+ArrayListEnumeratorSimpleMaximumAliasCount 4096MaximumDriveCount 4096MaximumErrorCount 256MaximumFunctionCount 4096MaximumHistoryCount 4096MaximumVariableCount 4096MyInvocation System.Management.Automation.InvocationInfoNestedPromptLevel 0nullOutputEncoding System.Text.ASCIIEncodingPID 8796PROFILE C:\\Users\\aaaaa\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1ProgressPreference ContinuePSBoundParameters &#123;&#125;PSCommandPathPSCulture zh-CNPSDefaultParameterValues &#123;&#125;PSEdition DesktopPSEmailServerPSHOME C:\\Windows\\System32\\WindowsPowerShell\\v1.0PSScriptRootPSSessionApplicationName wsmanPSSessionConfigurationName http://schemas.microsoft.com/powershell/Microsoft.PowerShellPSSessionOption System.Management.Automation.Remoting.PSSessionOptionPSUICulture zh-CNPSVersionTable &#123;PSVersion, PSEdition, PSCompatibleVersions, BuildVersion...&#125;PWD C:\\Users\\aaaaaShellId Microsoft.PowerShellStackTracetrue TrueVerbosePreference SilentlyContinueWarningPreference ContinueWhatIfPreference False 查看变量类型变量可以自动存储任何PowerShell能够识别的类型信息，可以通过 $变量名.GetType() 查看和验证 PowerShell 分配给变量的数据类型 123456PS C:/&gt; $num=10PS C:/&gt; $num.gettype() #不区分大小写IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Int32 System.ValueType 删除变量如果不想继续使用自定义的变量，可以使用del variable:变量名的方法删除变量，注意此处无$符号 123456$a=0$a -eq $nullFalsedel variable:a$a -eq $null True PowerShell支持的变量类型和C#大体相同(没有了short、uint、ulong等)，大多都继承自System.ValueType类( .NET类)，其基本数据类型包括 整型 类型 名称 允许的值 所属类 byte 无符号整数(1字节) 0~255之间的整数 System.Byte sbyte 有符号整数(1字节) -128~127之间的整数 System.SByte int16 有符号短整型(2字节) -32768~32767之间的整数 System.Int16 uint16 无符号短整型(2字节) 0~65535之间的整数 System.UInt16 int 有符号整型 -2147483648~2147483647之间的整数 System.Int32 uint32 无符号整型 0~4294967295之间的整数 System.UInt32 long 有符号长整数(8字节) -9223372036854775808~9223372036854775807之间的整数 System.Int64 ulong 无符号长整数(8字节) 0~18446744073709551615之间的整数 System.UInt64 其实 int 、long 、以及下面的 float 都是 .NET的语法糖，真正的原生类型名是int32、int64、single 之类的类名 浮点型浮点数标准形式(float和double) $+/-m×2^e$其中m为尾数，e为阶码，尾数是一个非负数，阶码是一个整数PowerShell还支持一个特别的浮点数类型 decimal，其形式为$+/-m×10^e$ 类型 名称 指数 m范围 e范围 近似最小值 近似最大值 所属类 float 单精度浮点数 2 0~$2^{24}$ -149~104 $1.5×10^{-45}$ $3.4×10^{38}$ System.Single double 双精度浮点数 2 0~$2^{53}$ -1075~970 $5.0×10^{-324}$ $1.7×10^{308}$ System.Double decimal 16字节浮点数 10 0~$2^{96}$ -28~0 $1.0×10^{-28}$ $7.9×10^{28}$ System.Decimal 其他简单类型除了数值类型以外，还有3种基本类型 类型 名称 允许的值 所属类 char 字符型 一个Unicode字符，存储0~65535之间的整数 System.Char bool 布尔型 布尔值: $true 或 $false(必须加$符号) System.Boolean enum 枚举 限定取值一组命名常量的独特的值类型 System.Enum datetime 时间型 包含日期、时间的类型 System.DateTime string 字符串 一组字符 System.String 注意 C/C++的 char 仅支持ASCII里面的256个字符, PowerShell 和 C# 的 char 是支持Unicode的， PowerShell和C#的string类型并不是继承自 System.ValuType 类，而是继承自 System.Object 类，因此严格来说 string 类型并非是简单类型。PowerShell的转义字符是 ` 而不是 \\，这也是和C#的一个区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#使用charPS D:/&gt;[char]$c=\"A\"$cA#使用boolPS D:/&gt;$boolean=$true$booleanTrue#使用enumenum fruit&#123; apple banana cherry durian&#125;[fruit]$en=[fruit]::apple$enapple$item=\"cherry\"[fruit]$enu=[fruit]::($item)$enucherry#这种使用方法是错误的PS D:/&gt; [fruit]$enum=bananabanana : 无法将“banana”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 12+ [fruit]$en=banana+ ~~~~~~ + CategoryInfo : ObjectNotFound: (banana:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException#当尝试使用非枚举值进行赋值时PS D:/&gt; [fruit]$en=[fruit]::peach由于枚举值无效，无法将 Null 转换为类型“fruit”。请指定以下枚举值之一，然后重试。可能的枚举值为“apple,banana,cherry,durian”。所在位置 行:1 字符: 1+ [fruit]$en=[fruit]::peach+ ~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeExceptionPS D:/&gt; \"\\n 123 `n 123\"&lt;#输出\\n 123 123#&gt;PS D:/&gt;$date=get-date$date$date.gettype()&lt;#输出2019年3月28日 19:32:30IsPublic IsSerial Name BaseType-------- -------- ---- --------True True DateTime System.ValueType#&gt; 赋值和返回值赋值操作符为 =，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令，因为 PowerShell 支持面向对象，对象可以包罗万象。 1234567891011121314151617181920PS D:\\powershell\\test&gt; $item=lsPS D:\\powershell\\test&gt; $item 目录: D:\\powershell\\testMode LastWriteTime Length Name---- ------------- ------ -----a---- 2017/11/24 12:52 136 4-3.cpp-a---- 2019/3/27 15:13 65 anapple.txtPS D:\\powershell\\test&gt; $item.gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Object[] System.Array$item为一个对象数组 弱类型与强类型一般对 PowerShell 变量重新赋值时，变量类型会自动改变，这是弱类型语言的特点；而 PowerShell 依托的 .NET是强类型的，所以 PowerShell 可以使用强类型。强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。可以在变量前添加类型限定符使该变量变为强类型，可以确保变量的类型不会随着赋值而改变 123456789[int]$num=123 #正确[int]$num=ls &lt;#错误无法将“System.Object[]”类型的“System.Object[]”值转换为“System.Int32”类型。所在位置 行:1 字符: 1+ [int]$num=ls+ ~~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException#&gt; 类型转换PowerShell 能够非常方便地将字符串等基本类型转换成期望的类型。之所以神奇，是因为 PowerShell 本身做了很多辛苦的工作，按照优先级： 直接赋值：输入类型和期望类型一致，可以直接交付。 基于语言的类型转换：当目标类型为void,Boolean,String , Array , Hashtable , PSReference (i.e.: [ref]), XmlDocument , Delegate 和 Enum 时，基于语言的类型转换开始工作。 Parse 转换：如果目标类型包含了 Parse() 方法，则采用它。 Static Create 转换：如果目标类型包含静态的Create，则采用它。 构造函数转换：如果目标类型定义了构造函数，采用它。 Cast 转换：如果目标类型定义了从源类型的显式或者隐式的操作符，则采用它。 IConvertible 接口转换：如果目标类型实现了支持源类型IConvertible 接口，则采用它。 IDictionary 转换：如果源类型是词典或者哈希表，会尝试创建一个实例，然后来填充name和value属性。 PSObject 属性转换：如果源类型是PSObject，通过目标类型的默认的构造函数创建一个实例，然后使用PSObject中的属性名称和值来填充实例的属性。 TypeConverter 转换：如果存在注册的 TypeConverter 或 PSTypeConverter 来处理转换，则使用它。 注意对浮点数向整数进行类型转换时，会自动四舍五入！！如果要C++/C#那种向下取整的方法请使用 [math]::Floor() 函数看几个转换的例子 12345PS D:/test&gt; $s=12.56PS D:/test&gt; [int]$s13PS D:/test&gt; [convert]::ToInt32($s)13 [convert]::ToInt32() 是 .NET System.Convert 类提供的转换函数convert 类中的转换函数格式为:TO+原生类型名()，这里的原生类型名指的是各个类型实际类名常用： [convert]::ToInt32() [convert]::ToSingle() [convert]::ToDouble() [convert]::ToBoolean() [convert]::ToString() convert 类提供了一系列方法来完成不同变量之间的转换，获得函数列表及使用方法请参考微软的 .NET文档Convert类 方法列表 运算符注意逻辑运算符和比较运算符的写法,不支持 C# 的&amp;&amp; || ！ == != &lt; &gt; &gt;= &lt;=这些运算符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#加 减 乘 除 取余+ - * / %#自增、自减运算符，和C#或C++完全一致++$i$i++$i----$i#且-and#并-or#非-not!#样例$true -and $false -or -not 0!$true#输出TrueFalse#等于 (equal to)-eq#不等于 (not equal to)-nq#大于 (greater than)-gt#大于等于 (greater than or equal to)-ge#小于 (less than)-lt#小于等于 (less than or equal to)-le#对于字符串类型，可以在比较运算符前加i或c表示是否区分大小写,#i表示对大小写不敏感，c表示敏感，不写默认不敏感\"a\" -eq \"A\"\"a\" -ceq \"A\"#输出TrueFalse#判断变量是否为兼容类型(同一类型或其父类型)，类型格式为 [类型名]-is#示例$a=0$a -is [int]$b=1,2,3$b -is [array]$a -is [ValueType]#输出TrueTrueTrue # System.Int32类继承自System.ValueType类，因此int是其父类型ValueType的子类型 条件分支if elseif 和 else 用法和C#完全一样，除了大括号不允许省略，多分支时还多了个elseif 可用，和Python 的 elif 作用相同 123456789if($true -and $true) &#123; $a=0&#125;elseif($a -eq $b) &#123; $a=1&#125;else &#123; $a=2&#125; switchPowerShell的switch非常灵活，使用起来较为方便相对C#或C++，PowerShell的switch不需要写`case:``，但是必须写大括号 123456$a=\"Beijing\"switch($a) &#123; \"Beijing\" &#123;$res=\"北京\"&#125; \"Shanghai\" &#123;$res=\"上海\"&#125;&#125; 默认比较运算符为-eq，你也可以使用下面的例子自定义比较条件，必须保证表达式返回boolen类型($true和$false) 12345678910$v=18switch($v)&#123; &#123;$_ -lt 10&#125; &#123;\"小于10\"&#125; # $_ 表示当前的传入的变量 直接写的字符串会被输出 10 &#123;\"等于10\"&#125; &#123;$_ -gt 10&#125; &#123;\"小于10\"&#125;&#125;&lt;#输出大于10#&gt; 循环接下来介绍循环 for循环PowerShell 的 for 循环类似于C#，看一个样例: 1234for($i=0;$i -lt 10;$i++)&#123; Write-Output \"Hello\"&#125; do-while循环Do 和 While 可能产生死循环，为了防止死循环的发生，因此我们必须确切的指定循环终止的条件。指定了循环终止的条件后，一旦条件不满足就会退出循环。do-while() 会先执行再去判断，能保证循环至少执行一次。 1234567891011do &#123; $n=Read-Host \"请输入数字\"&#125; while($n -ne 0)&lt;#输出请输入数字: 1请输入数字: 2请输入数字: s请输入数字: 0#&gt; 只使用while123456789101112$n=5while($n -gt 0)&#123; $n $n=$n-1&#125;#输出54321 跳出循环使用 continue 关键字，可以终止当前循环，跳过 continue 后其它语句，重新下一次循环。跳出循环语句使用 break 关键字 1234567891011121314151617181920212223242526272829$n=1while($n -lt 6)&#123; if($n -eq 4) &#123; $n=$n+1 continue &#125; else &#123; $n &#125; $n=$n+1&#125;1235$n=1while($n -lt 6)&#123; if($n -eq 4) &#123; break &#125; $n $n++&#125; 还有一种循环 foreach ，等到我们讲到数组再说 数组定义数组在 PowerShell 中创建数组可以使用逗号 123456PS C:/Powershell&gt; $nums=2,0,1,2PS C:/Powershell&gt; $nums2012 对于连续的数字数组可以使用一个更快捷的方法: 1234567PS C:/Powershell&gt; $nums=1..5PS C:/Powershell&gt; $nums12345 对象数组的多态像变量一样，如果数组中元素的类型为弱类型，默认可以存储不同类型的值。 123456789101112131415161718192021222324252627282930313233PS C:/Powershell&gt; $array=1,\"2019\",([Guid]::NewGuid()),(get-date)PS C:/Powershell&gt; $array12019Guid----ea5f17c6-c0a2-42ba-9de4-e4d03bebffafDisplayHint : DateTimeDate : 2019/3/29 0:00:00Day : 29DayOfWeek : FridayDayOfYear : 88Hour : 23Kind : LocalMillisecond : 120Minute : 23Month : 3Second : 39Ticks : 636894986191207086TimeOfDay : 23:23:39.1207086Year : 2019DateTime : 2019年3月29日 23:23:39PS C:/Powershell&gt; $array|foreach&#123;$_.gettype()&#125;#查看数组各元素类型IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Int32 System.ValueTypeTrue True String System.ObjectTrue True Guid System.ValueTypeTrue True DateTime System.ValueType 空数组和单元素数组对数组元素可以查看它的公有属性，比如长度只需要输入$数组名.Count即可显示数组长度 空数组12345PS C:/Powershell&gt; $a=@()PS C:/Powershell&gt; $a -is [array]TruePS C:/Powershell&gt; $a.Count0 单元素数组12345PS C:Powershell&gt; $a=,\"moss\"PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count1 使用数组遍历直接法将数组作为单独一行将会自动遍历这个数组的所有元素 123456789101112PS C:/&gt; $a=1..10PS C:/&gt; $a12345678910 for 循环遍历123456789PS C:/&gt; $a=1..5PS C:/&gt; for($i=0;$i -lt 5;$i++) &#123;&gt;&gt; $a[$i] &#125;12345&#125; foreach 遍历法还有一种遍历的方法，用到了之前提到的 foreach 语句意思是使用变量 $n 对 $a 元素进行迭代，这实际上是一种对可迭代对象的访问算法在 C# 也有这种语法 1234567891011$a=\"A\",\"B\",\"C\",\"D\",\"E\"foreach($n in $a)&#123; $n+\" \"+$n&#125;#输出A AB BC CD DE E foreach还有一种遍历的写法 这里我们需要先了解一下管道管道的符号 |管道允许将它左侧命令的输出结果发送到右侧做命令的参数管道并不是什么新事物，以前的Cmd控制台也有重定向的命令，例如Dir | More可以将结果分屏显示。传统的Cmd管道是基于文本的，但是 PowerShell 是基于对象的 列出当前目录下的目录和文件，然后根据文件名降序排列，再投影(数据库术语)文件名，文件大小，文件的修改时间: 123456789101112PS D:/test&gt; ls | Sort-Object -Descending Name | Select-Object Name,Length,LastWriteTime 目录: D:/testName Length LastWriteTime---- ------ -------------out.txt 523 2019/2/24 22:46:35lang.json 6415 2019/2/16 23:49:24anapple.txt 65 2019/3/27 15:13:524-3.cpp 136 2017/11/24 12:52:28 可迭代对象(比如数组)可以由管道送到一些命令上进一步处理foreach就可以接受管道送来的可迭代对象，并进行遍历 1234567891011$array=\"A\",\"B\",\"C\",\"D\",\"E\"$array|foreach&#123; $_+\"s\"&#125;#输出AsBsCsDsEs 将数组逆序输出12345PS C:/Powershell&gt; $books=\"A1\",\"B2\",\"C3\"PS C:/Powershell&gt; $books[($books.Count)..0]C3B2A1 访问某些元素与C#相同，数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是 PowerShell 为了使用方便，直接可以将 -1 作为最后的一个元素的索引(参考了 Python 的语法) 123456789PS C:/Powershell&gt; $books=\"1A\",\"2B\",\"3C\"PS C:/Powershell&gt; $books[0]1APS C:/Powershell&gt; $books[1]2BPS C:/Powershell&gt; $books[($book.Count-1)]3CPS C:/Powershell&gt; $books[-1]3C 从数组中选择多个元素12345678910PS C:/Powershell&gt; $result=lsPS C:/Powershell&gt; $result[0,3,5,12] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/24 17:37 7420 name.html 给数组添加元素因为PowerShell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用 += 操作符。 1234567PS C:/Powershell&gt; $books=\"A1\",\"B2\",\"C3\"PS C:/Powershell&gt; $books+=\"D4\"PS C:/Powershell&gt; $booksA1B2C3D4 删除指定位置元素采用截断重连法删除指定元素 1234567891011PS C:/Powershell&gt; $num=1..4PS C:/Powershell&gt; $num1234PS C:/Powershell&gt; $num=$num[0..1]+$num[3] #相当于删掉了第三项PS C:/Powershell&gt; $num124 复制数组数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用 Clone() 方法( System.Array 类的成员函数)，除非有特殊需求。 1234567891011121314151617PS C:/Powershell&gt; $chs=@(\"A\",\"B\",\"C\")PS C:/Powershell&gt; $chsBak=$chsPS C:/Powershell&gt; $chsBak[1]=\"H\"PS C:/Powershell&gt; $chsAHCPS C:/Powershell&gt; $chs.Equals($chsBak)TruePS C:/Powershell&gt; $chsNew=$chs.Clone()PS C:/Powershell&gt; $chsNew[1]=\"Good\"PS C:/Powershell&gt; $chs.Equals($chsNew)FalsePS C:/Powershell&gt; $chsAHC 强类型数组PowerShell 数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常，这样的数组被称为强类型数组定义方法[类型[]]$数组名=初值 12345678910PS C:/Powershell&gt; [int[]] $nums=@()PS C:/Powershell&gt; $nums+=2012PS C:/Powershell&gt; $nums+=12.3PS C:/Powershell&gt; $nums+=\"999\"PS C:/Powershell&gt; $nums+=\"can not convert\"Cannot convert value \"can not convert\" to type \"System.Int32\". Error: \"Input string was not in a correct format.\"At line:1 char:6+ $nums &lt;&lt;&lt;&lt; +=\"can not convert\" + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException 命令返回数组当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。但是，事实上 PowerShell 会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时， PowerShell 也会自动把结果存储为数组 12345678910111213141516171819202122232425262728293031323334353637383940414243PS C:/Powershell&gt; $IPcfg=ipconfigPS C:/Powershell&gt; $IPcfg&lt;#输出Windows IP 配置以太网适配器 以太网: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : lan无线局域网适配器 本地连接* 1: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :无线局域网适配器 本地连接* 2: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : **** IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . :以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::f88d:cd97:5343:9713%16 IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : **** 本地链接 IPv6 地址. . . . . . . . : fe80::954:3964:3731:997e%18 IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . : ****#&gt;PS C:/Powershell&gt; $IPcfg.Count37 使用数组存储结果判断一个变量是否为数组 12345678PS C:/Powershell&gt; $ip=ipconfigPS C:/Powershell&gt; $ip -is [array]TruePS C:/Powershell&gt; \"abac\" -is [array]FalsePS C:/Powershell&gt; $str=\"字符串\"PS C:/Powershell&gt; $str.ToCharArray() -is [array] #转换为字符数组True 使用真实的对象操作为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令(事实上ipconfig是一个单独的程序)，真正的 PowerShell 命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。 1234567891011121314151617181920212223242526272829PS D:/test&gt; $list=lsPS D:/test&gt; $list 目录: D:/testMode LastWriteTime Length Name---- ------------- ------ -----a---- 2017/11/24 12:52 136 4-3.cpp-a---- 2019/3/27 15:13 65 anapple.txtPS D:/test&gt; $list.gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Object[] System.ArrayPS D:/test&gt; foreach($i in $list)&#123;$i.name&#125;4-3.cppanapple.txtPS D:/test&gt; $list[0].gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True FileInfo System.IO.FileSystemInfo 上面的例子中数组的每一个元素存放的是一个 System.IO.DirectoryInfo 对象。当我们输出这些对象时，PowerShell 会自动帮我们把它转换成友好的文本格式。对于任何一个对象都可以使用 Format-List * 来查看它所有的属性和方法。 123456789101112131415161718192021222324252627282930313233343536373839404142PS D:/test&gt; $list[0]|fl * # \"|\"符号是管道符，将左边返回结果做参数发送到右侧，fl是Format-List的简称PSPath : Microsoft.PowerShell.Core\\FileSystem::D:test\\4-3.cppPSParentPath : Microsoft.PowerShell.Core\\FileSystem::D:\\testPSChildName : 4-3.cppPSDrive : DPSProvider : Microsoft.PowerShell.Core\\FileSystemPSIsContainer : FalseMode : -a----VersionInfo : File: D:\\test\\4-3.cpp InternalName: OriginalFilename: FileVersion: FileDescription: Product: ProductVersion: Debug: False Patched: False PreRelease: False PrivateBuild: False SpecialBuild: False Language:BaseName : 4-3Target : &#123;&#125;LinkType :Name : 4-3.cppLength : 136DirectoryName : D:\\testDirectory : D:\\testIsReadOnly : FalseExists : TrueFullName : D:\\test\\4-3.cppExtension : .cppCreationTime : 2019/3/27 15:07:32CreationTimeUtc : 2019/3/27 7:07:32LastAccessTime : 2019/3/27 15:07:32LastAccessTimeUtc : 2019/3/27 7:07:32LastWriteTime : 2017/11/24 12:52:28LastWriteTimeUtc : 2017/11/24 4:52:28Attributes : Archive 函数函数是自定义的 Powershell 代码，有三个原则： 简短：函数名简短，并且显而易见。 聚合：函数可以完成多个操作。 封装和扩展：将一批 Powershell 语句进行封装，实现全新的功能需求。函数的结构由三部分组成：函数名，参数，函数体 定义函数脚本中函数的定义方法函数可以在文本编辑器上编写，写完以后复制进 PowerShell 控制台即可。如果控制台设置为快速编辑模式，从记事本复制后，直接在控制台鼠标右键即可完成粘贴(Windows 10默认开启了快速编辑模式) 1234function FuncName(args[]) #括号可省略&#123; &lt;#代码段#&gt;&#125; 控制台上多行输入定义函数12345PS C:/PowerShell&gt; function MyPing&gt;&gt; &#123;&gt;&gt; PING.EXE -n 1 $args&gt;&gt; &#125;PS C:/PowerShell&gt; 把函数精简成一行我们可以将一个函数定义在一行上，但是这样阅读和理解起来就不方便，所以要在每条命令后加分号进行分割(最后一句可以不写;) 12PS C:/PowerShell&gt; function cd...&#123; cd.. ; cd.. &#125;PS C:/PowerShell&gt; cd... 使用函数作为别名假如 PowerShell 不支持 Get-SystemVersion 命令，你可以通过定义函数实现这个功能： 12345678910function get-systemversion&#123; $psversiontable.BuildVersion&#125;Get-SystemVersionMajor Minor Build Revision----- ----- ----- --------10 0 17134 590 更新函数如果要更新已经定义好的函数，简单的方法是重新定义，这样新的定义会覆盖旧的定义。但是如果函数代码没有保存副本，可以先将函数定义导出到ps文件，然后就可以编辑了。 1234567891011121314PS C:/PowerShell&gt; function MyPing&gt;&gt; &#123;&gt;&gt; PING.EXE -n 1 $args&gt;&gt; &#125;PS C:/PowerShell&gt; $function:MyPing | Out-File myPing.ps1PS C:/PowerShell&gt; $function:MyPingPING.EXE -n 1 $argsPS C:/PowerShell&gt; $function:MyPing | Out-File myPing.ps1PS C:/PowerShell&gt; .myPing.ps1必须指定 IP 地址。PS C:/PowerShell&gt; notepad.exe $$ 删除函数控制台定义的函数只会在当前会话生效，一旦控制台退出，会自动消失。在不关闭控制台的条件下删除一个已经定义好的函数，可是使用虚拟驱动器的方法： 1234567891011function cc&#123;\"hello\"&#125;PS C:/&gt; cchelloPS C:/&gt; del function:ccPS C:/&gt; cccc : 无法将“cc”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ cc+ ~~ + CategoryInfo : ObjectNotFound: (cc:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException 输入输出函数用于脚本文件的编写 输入PowerShell提供了 Read-Host 命令，可以接收返回用户在控制台输入的字符 1234567$name=read-host \"请输入你的名字\" #会把提示信息打印到PS控制台，也可以不写提示信息&lt;#执行+输入 结果:请输入你的名字: Nougat #&gt;$nameNougat 注意到 提示信息(如果有)后面自动加了个冒号； 用户键入任何信息都被作为该命令的返回结果； 可以把键入的信息传递给一个变量； 输出有两种输出命令Write-Host和Write-Output若输出字符串不包含空白字符可以不加引号 Write-Host当需要展示一个特定信息，比如使用其他颜色来吸引人们的注意力的时候，可使用 Write-Host 命令 Write-Host 和其他Cmdlets一样使用管道，但是它不放置任何数据道管道中。反而会直接写到宿主应用程序的界面。正如此，可以使用-ForegroundColor 和 -BackgroundColor 参数将前景和背景设置为其他颜色： 12write-host \"啊哈\" -ForegroundColor White -BackgroundColor Red啊哈 注：不是每个使用PowerShell的应用程序都支持其他颜色，也并不是每个应用程序都支持所有颜色。 该输出方法不适用于常规的输出结果，因为 Write-Host 命令输出到屏幕的任何东西都无法被捕捉。若执行远程命令或无人值守命令(纯自动化)， Write-Host 可能不会按照你的预期工作。因此，此命令仅仅用于与人进行直接交互。 Write-OutputWrite-Output命令会将对象发送给管道。由于它不会直接发送到显示界面，所以不允许你指定其他任何的颜色。 它是PowerShell默认使用的一个Cmdlets，默认输出方式即使用该命令，即使你没有指定，PowerShell会在底层将信息传递给Write-Output命令(就是一行直接写一个变量就能直接输出的情况)，另外这个命令还有两个别名 write 和 echo 123456write-host ACB #无空白字符可以不写引号 ACBwrite \"ABC\"ABCecho \"ABD\"ABD Write-Output输出基本过程为： Write-Output命令将string类型的对象Hello World!放入管道中； 管道中只有这个string对象，其会直接到达管道的末端，也就是Out-Default命令； Out-Default命令将对象传递给Out-Host命令； Out-Host命令要求PowerShell的格式化系统格式化该对象。 Out-Host将格式化的结果集放在显示界面上 还有一点，在输出多个对象时，Write-Host会以空格隔开各对象Write-Output会以换行隔开各对象 123456write-host \"ABC\" \"23232\"ABC 23232write-output \"ABC\" \"23232\"ABC 23232 其他的输出方式Write-Warning/Verbose/Debug/Error 具体参考：微软官方文档 处理函数参数PowerShell 函数可以接受参数，并对参数进行处理。函数的参数有3个特性： 任意参数：内部变量$args 接受函数调用时接受的参数，$args是一个数组类型； 命名参数：函数的每一个参数可以分配一个名称，在调用时通过名称指定对应的参数； 预定义参数：函数在定义参数时可以指定默认值，如果调用时没有专门指定参数的值，就会保持默认值； $args 万能参数给一个函数定义参数最简单的是使用$args这个内置的参数。它可以识别任意个参数。尤其适用那些参数可有可无的函数。 123456789101112131415161718192021222324252627282930function sayHello&#123; if($args.Count -eq 0) &#123; \"No argument!\" &#125; else &#123; $args | foreach &#123;\"Hello,$($_)\"&#125; &#125;&#125;#无参调用sayhello#输出No argument!#一参调用sayhello \"World!\" #也可以写成sayhello(\"World!\")#输出Hello,World!#多参数调用$str=\"it's me.\"sayhello 123 \"aha\" $str #如果字符串不包含空白字符(比如空格)，引号可以不写&lt;#输出Hello,123Hello,ahaHello,it's me.#&gt; 因为 $arg 是一个数组,可以用它很方便的写出求和函数 12345678function Add&#123; $sum=0 $args | foreach &#123;$sum=$sum+$_&#125; $sum&#125;Add 10 7 3 100#120 使用固定参数12345678910function StringContact($str1,$str2)&#123; return $str1+$str2&#125; StringContact LN P#StringContact -str1 word -str2 press#StringContact(\"word\",\"press\")LNPwordpress 给参数定义默认值1234567function stringContact($str1=\"LN\",$str2=\"P\")&#123; return $str1+$str2&#125;stringContactLNP 使用强类型参数通过之前的例子发现将用户的参数传递给函数显得比较混乱。罪魁祸首就是PowerShell的参数解释器，它可以自动处理和分配参数给函数。函数的参数解释器比较傲慢，它对你提供的参数的信息完全不关心。它只会粗略地将参数进行分割，并且最大限度的进行自动类型转换。事实上，这种类型转换很多时候并不完美。所以最好提前能够对参数进行强类型限制 限制数字类型下面的函数执行后，会抛出异常因为 subtract 的参数定义了强类型，参数的类型可能引起函数的处理结果改变。 123456789101112131415161718192021222324252627function subtract([int]$value1,[int]$value2)&#123; return $value1-$value2&#125;subtract LN P#执行结果报错subtract : 无法处理对参数“value1”的参数转换。无法将值“LN”转换为类型“System.Int32”。错误:“输入字符串的格式不正确。”所在位置 行:1 字符: 10+ subtract LN P+ ~~ + CategoryInfo : InvalidData: (:) [subtract]，ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,subtractsubtract 8.1 7.90&lt;#结果为0，这是因为PowerShell对结果整型化时进行了四舍五入但是如果将上面的函数的参数定义为Double型#&gt;function subtract([double]$value1,[double]$value2)&#123; return $value1-$value2&#125;subtract 8.1 7.90.199999999999999&lt;#输出 0.199999999999999的原因就是 .NET使用IEEE754标准存储浮点数，由于这些小数转化二进制会无限循环，会根据一定精度截取尾数，这个问题引发了这种奇怪的结果，其实著名的0.1+0.2!=0.3也是这个原因导致的#&gt; 限制日期类型函数的参数解释器会自动尝试将字符串转换成日期类型，如果转换失败就是抛出异常看下面的例子 123456789101112131415161718function DayOfWeek([datetime]$date)&#123; return $date.DayOfWeek&#125;DayofWeek '1927-8-1'MondayDayofWeek 2008-8-1FridayDayofWeek 'abc'DayOfWeek : 无法处理对参数“date”的参数转换。无法将值“abc”转换为类型“System.DateTime”。错误:“该字符串未被识别为有效的 DateTime。有一个未知单词(从索引 0 处开始)。”所在位置 行:1 字符: 12+ DayofWeek 'abc'+ ~~~~~ + CategoryInfo : InvalidData: (:) [DayOfWeek]，ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,DayOfWeek Switch 参数Powershell 函数最简单的参数类型为布尔类型，除了使用 Bool 类型，也可以使用 Switch 关键字。下面的函数逆转字符串，但是可以通过 $try 参数进行控制，如果没有指定 $try 的值，默认值为 $false 12345678910111213141516171819function tryReverse( [switch]$try , [string]$source ) #此处switch完全可以换成bool&#123; [string]$target=\"\" if($try) &#123; for( [int]$i = $source.length -1; $i -ge 0 ;$i--) &#123; $target += $source[$i] &#125; return $target &#125; return $source&#125;tryReverse -source www.google.comtryReverse -try $true -source www.google.com#输出www.google.commoc.eloog.www 指定函数的返回值一个或多个返回值PowerShell 不像其它的编程语言，它的函数可以有多个返回值。如果你直接调用函数，返回值会在控制台输出。当然你也可以将结果存储在一个变量中进一步处理下面的例子演示返回一个值： 12345678910111213141516function Square([double]$num)&#123; return $num*$num&#125;#在控制台输出结果Square 9.8797.4169 #将结果赋值给变量$value=Square 9.87$value97.4169 #返回值为Double类型$value.GetType().FullNameSystem.Double 下面的例子演示返回多个值 123456789101112131415161718192021222324252627282930313233function gbMeasure($amount)&#123; \"$amount GB=$($amount) GB\" \"$amount GB=$($amount*1gb/1mb) MB\" \"$amount GB=$($amount*1gb/1kb) KB\" \"$amount GB=$($amount*1gb) B\"&#125; #函数返回4个值gbMeasure 11 GB=1 GB1 GB=1024 MB1 GB=1048576 KB1 GB=1073741824 B #将所有的返回值存储在一个变量中$result=gbMeasure 1$result 1 GB=1 GB1 GB=1024 MB1 GB=1048576 KB1 GB=1073741824 B #所有的返回值会自动存储在一个数组中$result=gbMeasure 1$result.GetType().NameObject[] #通过索引访问每个返回值$result=gbMeasure 1$result[3]1 GB=1073741824 B 总结一下，如果一个函数返回一个值，像其它编程语言一样，这个值包括它的类型信息会直接返回。但是如果遇到多个返回值，PowerShell会将所有的返回值自动构造成一个对象数组。可以通过索引访问数组 Return语句Powershell 会将函数中所有的输出作为返回值，但是也可以通过return语句指定具体的返回值。Return 语句会将指定的值返回，同时也会中断函数的执行，return后面的语句会被忽略 看一个例子 12345678910111213141516function test($num)&#123; 1 9 return 10 4 6&#125;test1910&lt;# 1 和 9 作为输出会返回return语句中的10 也会返回return 语句后的4和6会被忽略#&gt; 访问返回值一个函数返回了一个值还是多个值，是可以验证的。下面的例子会产生随机数，如果没有指定个数，默认会返回一个随机数，否则会返回指定个数的随机数 1234567891011121314151617181920function lottery([int]$number=1)&#123; $rand = New-Object system.random for ($i=1; $i -le $number; $i++) &#123; $rand.next(1,50) &#125;&#125;# 参数为空时，返回值不是数组:$result = lottery$result -is [array]False# 如果指定多个随机数时，返回值是数组类型:$result = lottery 10$result -is [array]True$result.count10 从函数的返回值中消除输出函数默认会将函数中的所有输出作为函数的返回值返回，这样很方便。但有时可能会将不必要的输出误以为返回值。写脚本程序时，可能需要自定义一些函数，这个函数可能只需要一个返回值，但是为了提高函数的可读性，可能会在函数增加一些注释输出行，或者使用write-host 1234567891011121314151617181920212223242526272829303132function Test()&#123; \"Try to calculate.\" \"3.1415926\" \"Done.\"&#125; #保存在变量中输出,$value=Test$value#输出Try to calculate.3.1415926Done. #如果要过滤注释，只输出，不作为返回值，#可以使用Write-Host命令function Test()&#123; Write-Host \"Try to calculate.\" \"3.1415926\" Write-Host \"Done.\"&#125;# 在变量值中保存返回值，在控制台输出注释行$value=Test#控制台输出Try to calculate.Done. # 测试返回值$value3.1415926 恭喜你！到此 PowerShell 基础入门算是完成了！之后将介绍 PowerShell 的进阶使用 附录PowerShell Math类常用函数表 函数名 调用写法 所在类 重载 描述 参数 sin [math]::sin(x) System.Math 1 返回x弧度的正弦值 double cos [math]::cos(x) System.Math 1 返回x弧度的余弦值 double abs [math]::abs(x) System.Math 7 返回x的绝对值 所有数值型 sqrt [math]::sqrt(x) System.Math 1 返回x的平方根 double pow [math]::pow(x,n) System.Math 1 返回x的n次幂 两参数都是double log [math]::log(x) System.Math 1 返回x的自然对数 double log [math]::log(x,n) System.Math 1 返回x的以n为底的对数 double min [math]::min(x,y) System.Math 11 返回x，y中的最小值 所有数值型 max [math]::max(x,y) System.Math 11 返回x，y中的最大值 所有数值型 floor [math]::ceiling(x) System.Math 2 返回x向下取整的结果 double、decimal ceiling [math]::ceiling(x) System.Math 2 返回x向上取整的结果 double、decimal math 类其他函数及详细用法参见微软文档: Math类","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/PowerShell/"}]},{"title":"记一次express后端的搭建","slug":"记一次express后端的搭建","date":"2019-04-30T12:21:25.000Z","updated":"2020-02-28T14:22:50.646Z","comments":true,"path":"2019/04/30/记一次express后端的搭建/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/04/30/记一次express后端的搭建/","excerpt":"Node.js作为网工人怎么能不会搭后端呢？今天就拿 Node.js 下的 Express 搭一个后端","text":"Node.js作为网工人怎么能不会搭后端呢？今天就拿 Node.js 下的 Express 搭一个后端 Node.js 是什么东西你可能没听说过 Node.js，但是应该听说过 JavaScript，你也应该知道 Chrome(谷歌浏览器) 吧 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境(Runtime，即运行时)。 &gt; Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 简介Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。它发布于 2009 年 5 月，由 Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装(底层调用 C/C++的相关库)。Node 对一些特殊用例进行优化，提供替代的 API，使得 V8 在非浏览器环境下运行得更好。V8 引擎执行 Javascript 的速度非常快，性能非常好。Node 是一个基于 Chrome JavaScript 运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞 I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 Express.js这是一个基于 Node.js 平台，快速、开放、极简的 Web 开发框架，为 Web 和移动应用程序提供一组强大的功能。其实就是一个 node 下很完善的一个后端框架，在众多 js 后端框架中 Express 是做到大而全的。 为什么选择 Express首先是因为node 相比 java 下的 spring，python 下的 django 之类开发效率高。node 平台编程语言还是 js，对于前端也很友好，即使想要面向对象也有 ECMA6 和 Typescript 可选；还有完善的包管理工具 npm 或者 yarn;express 框架非常易于使用，即使没有使用经验也能很快上手。而且其大而全的特性也是功能强大的表现，相关需求的插件很多，使用文档和教程也是不计其数，可以说是各种流行后端框架中最高效最轻量的一个了。 简单示例最简单的示例123456789101112var express = require('express');var app = express();app.get('/', function(req, res) &#123; res.send('Hello World');&#125;);var server = app.listen(8081, function() &#123; var host = server.address().address; var port = server.address().port; console.log('应用实例，访问地址为 http://%s:%s', host, port)&#125;); 通过 npm 文件名 就可以启动。 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 处理GET请求示例1234567app.get('/', function (req, res) &#123; // 处理访问'/'目录的回调函数 // 假设用户访问的是 /?name=string 执行结果就是输出 string console.log('您通过query指定的参数是',req.query.name); // 返回json响应 res.json(value);&#125;); 处理POST请求示例1234app.post('/', (req, res) =&gt; &#123; // 为了省事，函数我用lambda表达式表示了 // 假设用户向 '/' POST 一个 &#123; name: 'string' &#125; console.log('您提交的name字段值是 ',req.body.name); // 返回结果就是 string&#125;); 使用命令行生成器通过应用生成器工具 express-generator 可以快速创建一个应用的基本框架。 1234567# 要求 node.js 版本在 8.2.0 及以上npx express-generator# 如果低于 8.2.0 可以使用npm install -g express-generator# 安装完成后再执行express 详细信息请看教程 使用路由功能教程","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/Express/"},{"name":"后端","slug":"后端","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/后端/"},{"name":"网站搭建","slug":"网站搭建","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/网站搭建/"}]},{"title":"PowerShell入门指南(2)","slug":"PowerShell入门指南(2)","date":"2019-03-29T06:41:14.000Z","updated":"2020-02-25T12:17:39.406Z","comments":true,"path":"2019/03/29/PowerShell入门指南(2)/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/03/29/PowerShell入门指南(2)/","excerpt":"PowerShell入门指南(二)·挑战CMD和Bash的PowerShell作为CMD/Bash的代替使用如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用","text":"PowerShell入门指南(二)·挑战CMD和Bash的PowerShell作为CMD/Bash的代替使用如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用 PowerShell 命令 PowerShell 简称 CMD 命令 UNIX 命令 描述 Get-ChildItem gci,dir,ls dir ls 显示当前目录下的所有文件和文件夹 Test-Connection ping ping ping 向目标站点发送一个ICMP接受响应，检查网络连通性 Get-Content gc,type,cat type cat 获取文件内容 Get-Command gcm help type, which, compgen 列出可用的命令 Get-Help help,man help apropos,man 在控制台列出命令的使用文档 Clear-Host cls,clear cls clear 清除屏幕内容 Copy-Item cpi,copy,cp copy,xcopy,robocopy cp 拷贝文件/文件夹到指定位置 Move-Item mi,move,mv move mv 移动文件/文件夹到新位置 Remove-Item ri,del,erase,rmdir,rd,rm del,erase,rmdir,rd rm,rmdir 删除文件/文件夹 Rename-Item rni,ren,mv ren,rename mv 重命名文件/文件夹 Get-Location gl,cd,pwd cd pwd 显示当前工作目录 Pop-Location popd popd popd 将工作路径更改为最近压入堆栈的位置 Push-Location pushd pushd pushd 将工作路径存储到堆栈上 Set-Location sl,cd,chdir cd,chdir cd 更改当前工作目录 Tee-Object tee 不支持 tee 将输入通过管道传递到文件或变量 Write-Output echo,write echo echo 将字符或其他对象输出到标准输出流上 Get-Process gps,ps tlist,tasklist ps 列出当前全部进程 Stop-Process spps,kill kill,taskkill kill 终止指定进程 Select-String sls findstr find,grep 打印匹配的字符行 Set-Variable sv,set set env,export,set,setenv 创建或更改环境变量的内容 Invoke-WebRequest iwr,curl,wget[^1] 不支持 wget,curl 从Internet上的网页获取内容 *** [^1]:curl和wget不在PowerShell Core中，因此不会干扰调用非Windows操作系统的同名组件。 功能键和快捷键先来了解一下功能键和快捷键 ALT+F7 清除命令的历史记录 PgUp PgDn 显示当前会话的第一个命令和最后一个命令 Enter 执行当前命令 End 将光标移至当前命令的末尾 Del 从右开始删除输入的命令字符 Esc 清空当前命令行 F2 自动补充历史命令至指定字符(例如历史记录中存在Get-Process，按F2，提示”Enter char to copy up to”，键入 S，自动补齐命令:Get-Proce) F4 删除命令行至光标右边指定字符处 F7 对话框显示命令行历史记录 F8 检索包含指定字符的命令行历史记录 F9 根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看 ←/→ 左右移动光标 ↑/↓ 切换命令行的历史记录 Home 光标移至命令行最左端 Backspace 从右删除命令行字符 Ctrl+C 取消正在执行的命令 Ctrl+←/→ 在单词之间移动光标 Ctrl+Home 删除光标最左端的所有字符 Tab 自动补齐命令或者文件名数值计算我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。 12345678PS C:/pstest&gt; 1+2+36PS C:/pstest&gt; 0xABCD43981PS C:/pstest&gt; 3.14*10*10314PS C:/pstest&gt; 1+3-(2.4-5)*(7.899-4.444)12.983 PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB 12345678PS C:/pstest&gt; 1pb/1tb1024PS C:/pstest&gt; 1tb/1gb1024PS C:/pstest&gt; 1gb/1kb1048576PS C:/pstest&gt; 1gb/20mb*10kb524288 假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数为： 12PS C:/pstest&gt; 10GB/(80KB*5)/30873.813333333333","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/PowerShell/"}]},{"title":"PowerShell入门指南(1)","slug":"PowerShell入门指南1","date":"2019-03-29T06:32:58.000Z","updated":"2020-02-25T05:39:20.738Z","comments":true,"path":"2019/03/29/PowerShell入门指南1/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/03/29/PowerShell入门指南1/","excerpt":"Powershell入门指南(一)·PowerShell及CLI发展 不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。","text":"Powershell入门指南(一)·PowerShell及CLI发展 不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。 也许你也曾经打开过它，但是不知道它有什么用;或者你了解一些CMD命令，但是你发现在这个PowerShell里面有些命令好像不能执行了。而且这个PowerShell相比CMD启动也不算快，微软为什么要拿这个替换CMD呢？ 这要从早期的Windows的命令行背景说起： 背景用于个人计算机的每个Windows版本都包含一个用于管理操作系统的命令行解释程序(CLI)；Windows系统的前身，即MS-DOS，完全依赖CLI支持。在MS-DOS和Windows9x系列系统里面提供CLI功能的程序是COMMAND.COM，在Windows NT以及之后的各种系统是CMD.exe提供CLI支持的。这两者都支持一些内部命令。它们还包括基本的脚本语言(batch file)支持，这些脚本可以完成多种自动化工作，但是对于用户交互界面(GUI)的自动化工作，它们就完全无能为力了。这是因为对GUI这些操作对应脚本的等价操作来说是受限的，毕竟这是最基本的脚本环境，支持的功能不全。到了Windows Sever 2003发布的时候，这一情况有所改善，但是仍令人不满意。 其实Microsoft在1998年就试图通过对Windows 98引入Windows脚本宿主(WSH)来解决其中一些缺点，这个程序在系统中名叫cscript.exe，它集成了Active script[^1]脚本引擎，可以使用兼容的VBscript和JScript来编写，调用其他应用程序的API或者COM。然而，它有其自身的不足之处：的文档不是很容易获得，并且在几个有名的计算机病毒利用其安全协议中的弱点之后，迅速获得了作为脆弱的系统漏洞荣誉(大雾)。不同版本的Windows提供了各种专用命令行解释器（例如netsh和WMIC）及其只适用自己的命令，但它们之间不可互操作。 开发人员的设想在9月13日发表的一次采访中，Jeffrey Snover(PowerShell之父)解释了开发该项目的动机: “我一直推动管理的变更，然后我开始把一些UNIX工具适配到Windows平台，结果它们却不能工作，对吧？因为Windows 和Linux的核心架构有很大区别。在Linux上，一切都是ASCII文本文件，因此所有支持这种文件的软件都可以作为管理软件。想想看，使用AWK(文本处理工具)、grep(文本搜索工具)、sed(类似于AWK)管理你的系统是多么美好的事请！我把这些工具移植到Windows，结果它们对于系统的管理没有任何作用，因为所有的API返回的都是结构化的数据，因此那些UNIX软件没什么帮助。……我突然有了就是现在powershell这样子的想法，告诉别人说：‘嘿！没准我们可以把这个做得更好！’” 开发历程 2002年，微软开始开发一种新的命令行管理方法，名为Monad（也称为Microsoft Shell或MSH）的CLI。其背后的想法于2002年8月发表在一份名为Monad Manifesto的白皮书中。Monad将成为一个新的可扩展CLI，其设计新颖，能够自动执行各种核心管理任务。 微软于2003年10月在洛杉矶举行的专业发展大会上首次展示Monad。几个月后开始私人测试计划，最终推出公共测试计划。 Microsoft 于2005年6月17日发布了第一个Monad公共测试版， 2005年9月11日发布了Beta 2 2006年1月10日发布了Beta 3。 不久之后，2006年4月25日，Microsoft正式宣布Monad已重命名为Windows PowerShell，将其定位为其管理技术产品的重要组成部分。 名称更改和RC的一个重要方面是，它现在是Windows的一个组件，而不是附加产品。 PowerShell版本1的候选版本2于2006年9月26日发布，最终发布于2006年11月14日，并在TechEd Barcelona上发布。 早期版本的Windows PowerShell于2007年1月30日发布。 PowerShell v2.0开发在PowerShell v1.0发布之前就开始了。在开发过程中，Microsoft发布了三个社区技术预览（CTP）。Microsoft向公众提供了这些版本。 Windows PowerShell v2.0的最后一个CTP版本于2008年12月推出。 适用于Ubuntu 14.04 x64 上的Linux 6.0 Alpha 9的PowerShell PowerShell v2.0已于2009年8月完成并发布，作为Windows 7和Windows Server 2008 R2的组成部分。适用于Windows XP，Windows Server 2003，Windows Vista和Windows Server 2008的PowerShell版本于2009年10月发布，可供32位和64位平台下载。 Windows 10提供了PowerShell的测试框架 2016年8月18日，微软宣布他们开发了PowerShell开源和跨平台，支持Windows，macOS，CentOS和Ubuntu。源代码发布在GitHub上。转向开源创建了PowerShell的第二个版本，称为“PowerShell Core”，它运行在 .NET Core上。它与“Windows PowerShell”不同，后者在完整的 .NET Framework上运行。 从版本5.1开始，PowerShell Core与Windows Server 2016 Nano Server捆绑在一起 简介PowerShell是Microsoft的任务自动化和配置管理框架，由命令行shell和相关的脚本语言组成。最初只是一个Windows组件，称为Windows PowerShell，它于2016年8月18日通过PowerShell Core的推出而成为开源和跨平台。前者构建于 .NET Framework上，后者构建于 .NET Core上。 在PowerShell中，管理任务通常由cmdlet（发音为command-lets）执行，cmdlet是实现特定操作的专用 .NET 类。这些工作通过访问不同数据存储中的数据（如文件系统或注册表），这些数据存储通过提供程序提供给PowerShell 。第三方开发人员可以向PowerShell添加cmdlet和提供程序。自定义的脚本可以使用Cmdlet ，还可以打包成模块作为新的Cmdlet使用。 PowerShell提供对COM和WMI的完全访问，使管理员能够在本地和远程Windows系统以及WS-Management和CIM上执行管理任务，从而实现远程对Linux系统和网络设备的管理。PowerShell还提供了一个托管API，PowerShell运行时可以使用该API嵌入到其他应用程序中。然后，这些应用程序可以使用PowerShell功能来实现某些操作，包括通过图形界面公开的操作。Microsoft Exchange Server 2007 使用此功能将其管理功能公开为PowerShell指令和提供程序并实现作为PowerShell主机的图形管理工具，可通过调用必要的cmdlet来使用Exchange Sever 2007。其他Microsoft应用程序（包括Microsoft SQL Server 2008）也通过PowerShell cmdlet公开其管理界面。 PowerShell含有广泛的，基于控制台的自身帮助（类似于手册页在Unix外壳）通过键入Get-Help命令即可轻松获取使用方法。你可以通过Update-Help cmdlet 从Internet升级本地帮助内容，还能通过Get-Help &lt;命令名&gt; -online获取来自网络的帮助。 以上内容来自PowerShell - Wikipedia，背景和开发人员设想部分为笔者翻译(翻译如有问题欢迎指出)，开发历程和简介由Google提供翻译服务，笔者进行了校对。 版本 了解更多请参考： PowerShell - Wikipedia 最初使用代号“Monad”，PowerShell于2003年9月首次在专业开发者大会上公开展示。所有主要版本仍然受支持，并且每个主要版本都具有与先前版本的向后兼容性。 PowerShell 1.0PowerShell 1.0于2006年11月发布，适用于Windows XP SP2，Windows Server 2003 SP1和Windows Vista。它还是Windows Server 2008的可选组件。 PowerShell 2.0PowerShell 2.0与Windows 7和Windows Server 2008 R2集成，适用于Windows XP Service Pack 3，Windows Server 2003 Service Pack 2和Windows Vista Service Pack 1. PowerShell v2除了包含240多个新cmdlet之外，还包括对脚本语言和托管API的更改。 PowerShell 3.0PowerShell 3.0与Windows 8和Windows Server 2012集成在一起。Microsoft还为Windows 7 Service Pack 1，Windows Server 2008 Service Pack 1和Windows Server 2008 R2 Service Pack 1 提供了PowerShell 3.0 。 PowerShell 3.0是更大的软件包Windows Management Framework 3.0（WMF3）的一部分，它还包含支持远程处理的WinRM服务。Windows Management Framework 3.0的早期社区技术预览2（CTP 2）版本于2011年12月2日发布。 Windows Management Framework 3.0于2012年12月发布，并默认包含在Windows 8和Windows Server 2012中。 PowerShell 4.0PowerShell 4.0与Windows 8.1和Windows Server 2012 R2集成在一起。Microsoft还为Windows 7 SP1，Windows Server 2008 R2 SP1和Windows Server 2012提供了PowerShell 4.0。 PowerShell 5.0包含PowerShell 5.0的Windows Management Framework（WMF）5.0 RTM于2016年2月24日在发布严重错误的初始版本后重新发布到Web。主要功能包括OneGet PowerShell cmdlet，支持Chocolatey基于存储库的包管理，并将对交换机管理的支持扩展到第2层网络交换机。 PowerShell 5.1它与2016年8月2日的Windows 10 周年更新以及Windows Server 2016一起发布。PackageManagement现在支持代理，PSReadLine现在支持ViMode，并添加了两个新的cmdlet：Get-TimeZone和Set-TimeZone。LocalAccounts模块允许添加/删除本地用户帐户。 PowerShell 5.1的预览版已于2016年7月16日针对Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Server 2012和Windows Server 2012 R2 发布，并于2017年1月19日发布正式版。 PowerShell 5.1是第一个有两个版本的PowerShell，包括“桌面”和“核心”版本。“桌面”版本是在完整的 .NET Framework堆栈上运行的传统Windows PowerShell的延续。“Core”版本在 .NET Core上运行，并与Windows Server 2016 Nano Server捆绑在一起。为了减少占用空间，后者缺少一些功能，例如用于管理剪贴板的cmdlet或将计算机加入域，WMI版本1 cmdlet，事件日志cmdlet和配置文件。这是专为Windows制作的PowerShell的最终版本。 PowerShell 6.0PowerShell Core 6.0于2016年8月18日首次发布，当时微软公布了PowerShell Core并决定使该产品跨平台，独立于Windows，而且是免费和开源的。它于2018年1月10日实现了Windows，macOS和Linux的普遍可用性。它有自己的支持生命周期，并遵循Windows 10引入的Microsoft生命周期策略：仅支持最新版本的PowerShell Core。微软希望每六个月为PowerShell Core 6.0发布一个次要版本。 此版本PowerShell中最重要的变化是扩展到其他平台。对于Windows管理员，此版本的PowerShell没有任何主要的新功能。在2018年1月11日的社区访谈中，PowerShell团队被要求列出将从Windows PowerShell 5.1迁移到PowerShell Core 6.0的Windows IT专业人员可能发生的十大最令人兴奋的事情。作为回应，微软的Angel Calvo只能说出两个：跨平台和开源(这两个就足够了)。 目前Windows 10 上自带的最新版本是5.1[^1]:一种可以采用各种语言以及固定格式等实现、并能与其他 ActiveX 控件(可以理解为一种互联网插件)交互的脚本","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/PowerShell/"}]},{"title":"春节快乐","slug":"春节快乐","date":"2019-02-04T12:38:56.000Z","updated":"2020-02-25T05:39:38.634Z","comments":true,"path":"2019/02/04/春节快乐/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/02/04/春节快乐/","excerpt":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭! 笔者还准备了礼物送给大家，点击下面的阅读全文查看","text":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭! 笔者还准备了礼物送给大家，点击下面的阅读全文查看 献上笔者绘制的Peppa Pig(社会猪佩奇) 送上猪年祝福语 春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。 朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！ 猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！ 除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！ 春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。 猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！ 一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！ 春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！ 绘制佩奇使用的是PS的钢笔","categories":[],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/节日祝福/"},{"name":"春节","slug":"春节","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/春节/"}]},{"title":"HTML (一)","slug":"HTML (一)","date":"2019-01-25T13:36:08.000Z","updated":"2020-02-25T05:38:04.256Z","comments":true,"path":"2019/01/25/HTML (一)/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/01/25/HTML (一)/","excerpt":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。","text":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。 简介HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。现如今，HTML已经是程序员必须掌握的一项基本功。 HTML发展史HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。 *HTML 2.0——1995年11月，RFC 1866发布*HTML 3.2——1997年1月14日，W3C发布推荐标准*HTML 4.0——1997年12月18日，W3C发布推荐标准*HTML 4.01——1999年12月24日，W3C发布推荐标准*HTML 5——2014年10月28日，W3C发布推荐标准 HTML5编辑规范 文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg 浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车 标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。 必须使用半角而不是全角字符 HTML注释&lt;!--注释内容--&gt;的内容不给予显示。 这是笔者写的较为详细的一个入门页面HTML入门·一","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/HTML/"}]},{"title":"PowerShell (一)","slug":"PowerShell (一)","date":"2019-01-17T11:48:41.000Z","updated":"2020-02-25T12:38:29.911Z","comments":true,"path":"2019/01/17/PowerShell (一)/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/01/17/PowerShell (一)/","excerpt":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。","text":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。 介绍PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，PowerShell需要.NET环境的支持，借助 .NET Framework平台强大的类库，几乎让一切都成为可能。微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。 受众Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。 特点通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。PowerShell以 .NET Framework为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。PowerShell推出了一个功能强大的命令叫做cmdlet,所有的cmdlet命令都遵循动词-名词这样语法结构。如Get-Command, Get-Process等，即使从来没有接触过PowerShell，也很容易能够明白命令的作用。如Get-Process命令的意思就是获取所有的进程。 新的脚本语言由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。 PS1文件一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。 执行权限为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（Restricted），意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略： Get-ExecutionPolicy你可以选择使用的执行策略有： Restricted -脚本不能运行。 RemoteSigned - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 AllSigned – 仅当脚本由受信任的发布者签名才能运行。 Unrestricted –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。 你可以使用下面的cmdlet命令设置PowerShell的执行策略： 1Set-ExecutionPolicy &lt;policy name&gt; 运行脚本如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，但这个古老的方法现在却不能适用于PowerShell可执行脚本了。如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，例如，假设你要运行一个名为a.ps1的脚本，你可以键入：C:\\Scripts\\aps1最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符后键入脚本文件名即可运行，如：.\\a.ps1 注意前面需要加上.\\，这和Linux下执行Shell脚本的方法如出一辙。 管道管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（|）连接即可。为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，可以使用Get-Process cmdlet命令获得进程列表，但默认情况下列表不会排序，如果将这个cmdlet命令的输出用管道输送给Sort-Object ID命令，进程列表将会按进程ID号进行排序，如： 1Get-Process | Sort-Object ID 变量虽然可以使用管道将一个命令的输出输送给另一个命令，但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：$a = Get-Process在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，例如，键入$a便可在屏幕上打印变量的内容。你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令： 1$a = (Get-Process | Sort-Object ID) @符号通过使用@符号，你可以将列表内容转换成一个数组，例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：$procs = @{name=&quot;explorer&quot;,&quot;svchost&quot;}使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，例如，下面的代码将在我前面定义的变量上运行Get-Process cmdlet命令： 1Get-Process @procsWindows 将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的@符号，而不是常见的$符号。 SplitSplit操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到： 1\"This is a test\" -split \" \" 拆分后的结果如下：This is a test Join就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成： 1\"Brien\",\"Posey\" -join \" \" 命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。 断点运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令： 1234567New-PSBreakpoint -Script C:\\Scripts\\a.ps1 -Line 10#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：New-PSBreakpoint -Script C:\\scripts\\a.ps1 -variables a #注意，在变量名后并没有包括美元符号。#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。 Step调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用Step-Into cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用Step-Out cmdlet命令即可，但需要注意的是，使用Step-Out cmdlet命令后，断点仍然有效。顺便说一句，如果你的脚本使用了函数，你可能对Step-Out cmdlet更感兴趣，Step-Out 的工作方式和Step-Into 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。 因此PowerShell实际是一门独立的脚本语言了PowerShell能干什么？PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。 PowerShell能做下面这些事: .NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint, Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS, Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications. 基本上所有的微软产品都提供PowerShell接口。 1、管理进程前面已经提过管理系统进程的命令，管理进程常用命令就是get-process和stop-process，get-process获取进程之后可以直接用管道发送给stop-process结束进程。比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。 1get-process -Name notepad | stop-process 2、处理文件和文件夹PowerShell使用Get-ChildItem获取文件夹中直接包含的所有项，它有系统内置别名dir和ls，使用CMD和BASH的用户均可以轻松上手。如果想查看C:中的文件夹和文件，直接使用dir c:，PowerShell立刻就会列出C:中的文件和文件夹。其它处理文件和文件夹的命令有Copy-Item、New-Item、Remove-Item等，具体用法可以使用get-help然后跟命令名称即可查询。 3、处理系统服务可以像管理进程一样管理系统服务， Get-Service命令获取服务列表， Stop-Service命令停止服务， Start-Service命令启动服务， Suspend-Service命令挂起服务， Restart-Service命令重启服务， Set-Service服务设置服务属性。如果想一次性启动已经停止的服务，可以使用以下命令：1get-service | where-object &#123;$_.Status -eq \"Stopped\"&#125; -exclude 下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。wisvc | start-service 4、处理注册表PowerShell可以非常方便的处理注册表项目，与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。由于注册表对系统非常重要，错误处理注册表也许会导致系统出问题， 处理注册表，特别是删除注册表项目要非常小心， 最好能在处理注册表项目之前先备份要处理的项目。没有管理员权限也能处理部分注册表项目， 这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。 5、处理其它任务PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。 6、编写脚本程序借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。 一个有趣的例子这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。 12345678910111213141516171819202122232425# 创建新的excel com对象$objExcel = New-Object -comobject Excel.Application$objExcel.Visible = $True$objWorkbook = $objExcel.Workbooks.Add()$objWorksheet = $objWorkbook.Worksheets.Item(1)# 把信息写入excel$i = 0$first10 = (ps | sort ws -Descending | select -first 10)$first10 | foreach -Process &#123;$i++; $objWorksheet.Cells.Item($i,1) = $_.name; $objWorksheet.Cells.Item($i,2) = $_.ws&#125;$otherMem = (ps | measure ws -s).Sum - ($first10 | measure ws -s).Sum$objWorksheet.Cells.Item(11,1) = \"Others\"; $objWorksheet.Cells.Item(11,2) = $otherMem# 画饼图$objCharts = $objWorksheet.ChartObjects()$objChart = $objCharts.Add(0, 0, 500, 300)$objChart.Chart.SetSourceData($objWorksheet.range(\"A1:B11\"), 2)$objChart.Chart.ChartType = 70$objChart.Chart.ApplyDataLabels(5)#暂停pause$objExcel.Quit()$objExcel = $null[GC]::Collect() 执行结果:","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/PowerShell/"}]},{"title":"元旦快乐","slug":"元旦快乐","date":"2018-12-31T16:12:12.000Z","updated":"2020-02-25T05:44:05.679Z","comments":true,"path":"2019/01/01/元旦快乐/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2019/01/01/元旦快乐/","excerpt":"2019元旦快乐","text":"2019元旦快乐 相逢是首悠扬的歌，相识是杯醇香的酒，相处是那南飞的雁，相知是根古老的藤。健康是最佳的礼物，知足是最大的财富，信心是最可贵的品德，关心是最真挚的问候，牵挂是最无私的思念，祝福是最美好的话语！ 在此献上最美好的祝福祝各位朋友们2019年新年快乐！平安幸福！","categories":[],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/节日祝福/"},{"name":"元旦","slug":"元旦","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/元旦/"}]},{"title":"面向对象的程序设计","slug":"面向对象的程序设计","date":"2018-12-30T07:06:15.000Z","updated":"2020-02-25T05:40:44.723Z","comments":true,"path":"2018/12/30/面向对象的程序设计/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2018/12/30/面向对象的程序设计/","excerpt":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。","text":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。 特点面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。 发展面向对象是在结构化设计方法出现很多问题的情况下应运而生的。 结构化设计方法求解问题的基本策略是从功能的角度审视问题域。它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。 1. 审视问题域的视角 在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。 2. 抽象级别 抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。 3. 封装体 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。 4. 可重用性 可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。 上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。 面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地适应了潮流。 面向对象程序设计的思想也使事件处理式的程序设计更加广泛被应用 抽象的示例假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，首先想到的是开一个结构体，然后定义几个变量: 12345678struct Sheep&#123; int age; double height; double weight;&#125;;Sheep Jeff; //定义一只叫Jeff的羊 很容易，现在Jeff要跑，怎么办？于是就用一个run函数，把Jeff作为一个参数传递来实现: 123456void run(Sheep sheep)&#123; /* code */&#125;run(Jeff); 也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？ 这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；这样，所有的羊都有了一种叫跑步的方法，就方便多了: 123456789101112131415161718class Sheep &#123;public: void run(string method=\"default\"); void mie();//咩private: int age; double height,weight;&#125;;//定义一个Sheep类Sheep Jeff;Jeff.run(); //Jeff使用默认的方法跑步Sheep YangDaXia;YangDaXia.run(\"onFoot\"); //羊大侠站着跑Sheep XiYangYang;XiYangYang.run(\"shoes\"); //喜羊羊穿鞋跑","categories":[],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/面向对象/"},{"name":"C/C++","slug":"C-C","permalink":"https://lollipopnougat.github.io/Crepeblog/tags/C-C/"}]},{"title":"The first one","slug":"The-first-one","date":"2018-12-30T03:44:32.000Z","updated":"2020-02-25T05:39:30.725Z","comments":true,"path":"2018/12/30/The-first-one/","link":"","permalink":"https://lollipopnougat.github.io/Crepeblog/2018/12/30/The-first-one/","excerpt":"测试用页面","text":"测试用页面 第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1][^1]: 这是脚注 这是1级标题这是斜体这是加粗这是斜体加粗 这是删除 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello,world!\"; return 0; //这是代码段&#125; 这是2级标题这是代码块 这是3级标题 这是引述 这是引述嵌套 这是4级标题这是百度一下 -[x] 选项一-[ ] 选项二-[ ] 选项三 这是5级标题 这是无序列表 这是无序列表 这是无序列表 这是有序列表 这是有序列表 这是有序列表","categories":[],"tags":[]}]}