<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frank</title>
  
  
  <link href="/Crepeblog/atom.xml" rel="self"/>
  
  <link href="https://crepe.coding.me/Crepeblog/"/>
  <updated>2019-04-30T12:28:16.252Z</updated>
  <id>https://crepe.coding.me/Crepeblog/</id>
  
  <author>
    <name>Frank C.</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次express后端的搭建</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/04/30/%E8%AE%B0%E4%B8%80%E6%AC%A1express%E5%90%8E%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/04/30/记一次express后端的搭建/</id>
    <published>2019-04-30T12:21:25.000Z</published>
    <updated>2019-04-30T12:28:16.252Z</updated>
    
    <content type="html"><![CDATA[<p>作为网工人怎么能不会搭后端呢？<br>今天就拿Node.js下的Express搭一个简易后端</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为网工人怎么能不会搭后端呢？&lt;br&gt;今天就拿Node.js下的Express搭一个简易后端&lt;/p&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="https://crepe.coding.me/Crepeblog/tags/node-js/"/>
    
      <category term="express" scheme="https://crepe.coding.me/Crepeblog/tags/express/"/>
    
      <category term="后端" scheme="https://crepe.coding.me/Crepeblog/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(2)</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(2)/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/03/29/PowerShell入门指南(2)/</id>
    <published>2019-03-29T06:41:14.000Z</published>
    <updated>2019-03-29T06:44:09.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PowerShell入门指南-二-·挑战CMD和Bash的PowerShell"><a href="#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell" class="headerlink" title="PowerShell入门指南(二)·挑战CMD和Bash的PowerShell"></a>PowerShell入门指南(二)·挑战CMD和Bash的PowerShell</h1><h2 id="作为CMD-Bash的代替使用"><a href="#作为CMD-Bash的代替使用" class="headerlink" title="作为CMD/Bash的代替使用"></a>作为CMD/Bash的代替使用</h2><p>如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用</p><a id="more"></a><hr><table><thead><tr><th>PowerShell 命令</th><th>PowerShell 简称</th><th>CMD 命令</th><th>UNIX 命令</th><th>描述</th></tr></thead><tbody><tr><td>Get-ChildItem</td><td>gci,dir,ls</td><td>dir</td><td>ls</td><td>显示当前目录下的所有文件和文件夹</td></tr><tr><td>Test-Connection</td><td>ping</td><td>ping</td><td>ping</td><td>向目标站点发送一个ICMP接受响应，检查网络连通性</td></tr><tr><td>Get-Content</td><td>gc,type,cat</td><td>type</td><td>cat</td><td>获取文件内容</td></tr><tr><td>Get-Command</td><td>gcm</td><td>help</td><td>type, which, compgen</td><td>列出可用的命令</td></tr><tr><td>Get-Help</td><td>help,man</td><td>help</td><td>apropos,man</td><td>在控制台列出命令的使用文档</td></tr><tr><td>Clear-Host</td><td>cls,clear</td><td>cls</td><td>clear</td><td>清除屏幕内容</td></tr><tr><td>Copy-Item</td><td>cpi,copy,cp</td><td>copy,xcopy,robocopy</td><td>cp</td><td>拷贝文件/文件夹到指定位置</td></tr><tr><td>Move-Item</td><td>mi,move,mv</td><td>move</td><td>mv</td><td>移动文件/文件夹到新位置</td></tr><tr><td>Remove-Item</td><td>ri,del,erase,rmdir,rd,rm</td><td>del,erase,rmdir,rd</td><td>rm,rmdir</td><td>删除文件/文件夹</td></tr><tr><td>Rename-Item</td><td>rni,ren,mv</td><td>ren,rename</td><td>mv</td><td>重命名文件/文件夹</td></tr><tr><td>Get-Location</td><td>gl,cd,pwd</td><td>cd</td><td>pwd</td><td>显示当前工作目录</td></tr><tr><td>Pop-Location</td><td>popd</td><td>popd</td><td>popd</td><td>将工作路径更改为最近压入堆栈的位置</td></tr><tr><td>Push-Location</td><td>pushd</td><td>pushd</td><td>pushd</td><td>将工作路径存储到堆栈上</td></tr><tr><td>Set-Location</td><td>sl,cd,chdir</td><td>cd,chdir</td><td>cd</td><td>更改当前工作目录</td></tr><tr><td>Tee-Object</td><td>tee</td><td>不支持</td><td>tee</td><td>将输入通过管道传递到文件或变量</td></tr><tr><td>Write-Output</td><td>echo,write</td><td>echo</td><td>echo</td><td>将字符或其他对象输出到标准输出流上</td></tr><tr><td>Get-Process</td><td>gps,ps</td><td>tlist,tasklist</td><td>ps</td><td>列出当前全部进程</td></tr><tr><td>Stop-Process</td><td>spps,kill</td><td>kill,taskkill</td><td>kill</td><td>终止指定进程</td></tr><tr><td>Select-String</td><td>sls</td><td>findstr</td><td>find,grep</td><td>打印匹配的字符行</td></tr><tr><td>Set-Variable</td><td>sv,set</td><td>set</td><td>env,export,set,setenv</td><td>创建或更改环境变量的内容</td></tr><tr><td>Invoke-WebRequest</td><td>iwr,<del>curl,wget</del>[^1]</td><td>不支持</td><td>wget,curl</td><td>从Internet上的网页获取内容</td></tr><tr><td>[^1]:curl和wget不在PowerShell Core中，因此不会干扰调用非Windows操作系统的同名组件。</td><td></td><td></td><td></td><td></td></tr><tr><td>***</td><td></td><td></td><td></td><td></td></tr><tr><td>## 功能键和快捷键</td><td></td><td></td><td></td><td></td></tr><tr><td>#### 先来了解一下功能键和快捷键</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>ALT</kbd>+<kbd>F7</kbd>    清除命令的历史记录</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>PgUp</kbd> <kbd>PgDn</kbd>    显示当前会话的第一个命令和最后一个命令</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Enter</kbd>    执行当前命令</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>End</kbd>    将光标移至当前命令的末尾</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Del</kbd>    从右开始删除输入的命令字符</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Esc</kbd>    清空当前命令行</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>F2</kbd>    自动补充历史命令至指定字符</td><td></td><td></td><td></td><td></td></tr><tr><td>(例如历史记录中存在Get-Process，按<kbd>F2</kbd>，提示”Enter char to copy up to”，键入 <kbd>S</kbd>，自动补齐命令:Get-Proce)</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>F4</kbd>    删除命令行至光标右边指定字符处</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>F7</kbd>    对话框显示命令行历史记录</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>F8</kbd>    检索包含指定字符的命令行历史记录</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>F9</kbd>    根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>←</kbd>/<kbd>→</kbd>    左右移动光标</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>↑</kbd>/<kbd>↓</kbd>    切换命令行的历史记录</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Home</kbd>    光标移至命令行最左端</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Backspace</kbd>    从右删除命令行字符</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Ctrl</kbd>+<kbd>C</kbd>    取消正在执行的命令</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Ctrl</kbd>+<kbd>←</kbd>/<kbd>→</kbd>    在单词之间移动光标</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Ctrl</kbd>+<kbd>Home</kbd>    删除光标最左端的所有字符</td><td></td><td></td><td></td><td></td></tr><tr><td>* <kbd>Tab</kbd>    自动补齐命令或者文件名</td><td></td><td></td><td></td><td></td></tr><tr><td>## 数值计算</td><td></td><td></td><td></td><td></td></tr><tr><td>我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。</td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">0</span>xABCD</span><br><span class="line"><span class="number">43981</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">3.14</span>*<span class="number">10</span>*<span class="number">10</span></span><br><span class="line"><span class="number">314</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>+<span class="number">3</span>-(<span class="number">2.4</span>-<span class="number">5</span>)*(<span class="number">7.899</span>-<span class="number">4.444</span>)</span><br><span class="line"><span class="number">12.983</span></span><br></pre></td></tr></table></figure><p>PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">1</span>pb/<span class="number">1</span>tb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>tb/<span class="number">1</span>gb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>gb/<span class="number">1</span>kb</span><br><span class="line"><span class="number">1048576</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>gb/<span class="number">20</span>mb*<span class="number">10</span>kb</span><br><span class="line"><span class="number">524288</span></span><br></pre></td></tr></table></figure><p>假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">10</span>GB/(<span class="number">80</span>KB*<span class="number">5</span>)/<span class="number">30</span></span><br><span class="line"><span class="number">873.813333333333</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot;&gt;&lt;a href=&quot;#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot; class=&quot;headerlink&quot; title=&quot;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&quot;&gt;&lt;/a&gt;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&lt;/h1&gt;&lt;h2 id=&quot;作为CMD-Bash的代替使用&quot;&gt;&lt;a href=&quot;#作为CMD-Bash的代替使用&quot; class=&quot;headerlink&quot; title=&quot;作为CMD/Bash的代替使用&quot;&gt;&lt;/a&gt;作为CMD/Bash的代替使用&lt;/h2&gt;&lt;p&gt;如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://crepe.coding.me/Crepeblog/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(1)</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/03/29/PowerShell入门指南1/</id>
    <published>2019-03-29T06:32:58.000Z</published>
    <updated>2019-03-29T06:37:44.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Powershell入门指南-一-·PowerShell及CLI发展"><a href="#Powershell入门指南-一-·PowerShell及CLI发展" class="headerlink" title="Powershell入门指南(一)·PowerShell及CLI发展"></a>Powershell入门指南(一)·PowerShell及CLI发展</h1><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png" alt="PowerShell"></p><p>不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。</p><a id="more"></a><hr><p>也许你也曾经打开过它，但是不知道它有什么用;<br>或者你了解一些CMD命令，但是你发现在这个PowerShell里面有些命令好像不能执行了。<br>而且这个PowerShell相比CMD启动也不算快，<strong>微软为什么要拿这个替换CMD呢</strong>？这要从早期的Windows的命令行背景说起：</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用于个人计算机的每个Windows版本都包含一个用于管理操作系统的命令行解释程序(CLI)；Windows系统的前身，即MS-DOS，完全依赖CLI支持。在MS-DOS和Windows9x系列系统里面提供CLI功能的程序是<code>COMMAND.COM</code>，在Windows NT以及之后的各种系统是<code>CMD.exe</code>提供CLI支持的。这两者都支持一些内部命令。<br>它们还包括基本的脚本语言(batch file)支持，这些脚本可以完成多种自动化工作，但是对于用户交互界面(GUI)的自动化工作，它们就完全无能为力了。这是因为对GUI这些操作对应脚本的等价操作来说是受限的，毕竟这是最基本的脚本环境，支持的功能不全。到了Windows Sever 2003发布的时候，这一情况有所改善，但是仍令人不满意。</p><p>其实Microsoft在1998年就试图通过对Windows 98引入Windows脚本宿主(WSH)来解决其中一些缺点，这个程序在系统中名叫<code>cscript.exe</code>，它集成了Active script[^1]脚本引擎，可以使用兼容的<code>VBscript</code>和<code>JScript</code>来编写，调用其他应用程序的API或者COM。然而，它有其自身的不足之处：<br>的文档不是很容易获得，并且在几个有名的计算机病毒利用其安全协议中的弱点之后，迅速获得了作为脆弱的系统漏洞荣誉(大雾)。不同版本的Windows提供了各种专用命令行解释器（例如netsh和WMIC）及其只适用自己的命令，但它们之间不可互操作。</p><hr><h3 id="开发人员的设想"><a href="#开发人员的设想" class="headerlink" title="开发人员的设想"></a>开发人员的设想</h3><p>在9月13日发表的一次采访中，Jeffrey Snover(PowerShell之父)解释了开发该项目的动机:</p><blockquote><p>“我一直推动管理的变更，然后我开始把一些UNIX工具适配到Windows平台，结果它们却不能工作，对吧？因为Windows 和Linux的核心架构有很大区别。在Linux上，一切都是ASCII文本文件，因此所有支持这种文件的软件都可以作为管理软件。想想看，使用AWK(文本处理工具)、grep(文本搜索工具)、sed(类似于AWK)管理你的系统是多么美好的事请！<br>我把这些工具移植到Windows，结果它们对于系统的管理没有任何作用，因为所有的API返回的都是结构化的数据，因此那些UNIX软件没什么帮助。<br>……<br>我突然有了就是现在powershell这样子的想法，告诉别人说：‘嘿！没准我们可以把这个做得更好！’”</p></blockquote><hr><h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><ul><li><p>2002年，微软开始开发一种新的命令行管理方法，名为Monad（也称为Microsoft Shell或MSH）的CLI。其背后的想法于2002年8月发表在一份名为Monad Manifesto的白皮书中。Monad将成为一个新的可扩展CLI，其设计新颖，能够自动执行各种核心管理任务。</p></li><li><p>微软于2003年10月在洛杉矶举行的专业发展大会上首次展示Monad。几个月后开始私人测试计划，最终推出公共测试计划。</p></li><li><p>Microsoft 于2005年6月17日发布了第一个Monad公共测试版，</p></li><li><p>2005年9月11日发布了Beta 2</p></li><li><p>2006年1月10日发布了Beta 3。</p></li><li><p>不久之后，2006年4月25日，Microsoft正式宣布Monad已重命名为Windows PowerShell，将其定位为其管理技术产品的重要组成部分。 名称更改和RC的一个重要方面是，它现在是Windows的一个组件，而不是附加产品。</p></li><li><p>PowerShell版本1的候选版本2于2006年9月26日发布，最终发布于2006年11月14日，并在TechEd Barcelona上发布。</p></li><li><p>早期版本的Windows PowerShell于2007年1月30日发布。</p></li><li><p>PowerShell v2.0开发在PowerShell v1.0发布之前就开始了。在开发过程中，Microsoft发布了三个社区技术预览（CTP）。Microsoft向公众提供了这些版本。</p></li><li><p>Windows PowerShell v2.0的最后一个CTP版本于2008年12月推出。</p></li><li><p>适用于Ubuntu 14.04 x64 上的Linux 6.0 Alpha 9的PowerShell</p></li><li><p>PowerShell v2.0已于2009年8月完成并发布，作为Windows 7和Windows Server 2008 R2的组成部分。适用于Windows XP，Windows Server 2003，Windows Vista和Windows Server 2008的PowerShell版本于2009年10月发布，可供32位和64位平台下载。</p></li><li><p>Windows 10提供了PowerShell的测试框架</p></li><li><p>2016年8月18日，微软宣布他们开发了PowerShell开源和跨平台，支持Windows，macOS，CentOS和Ubuntu。源代码发布在GitHub上。转向开源创建了PowerShell的第二个版本，称为“PowerShell Core”，它运行在 .NET Core上。它与“Windows PowerShell”不同，后者在完整的 .NET Framework上运行。</p></li><li><p>从版本5.1开始，PowerShell Core与Windows Server 2016 Nano Server捆绑在一起</p></li></ul><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PowerShell是Microsoft的<strong>任务自动化和配置管理框架</strong>，由命令行shell和相关的脚本语言组成。最初只是一个Windows组件，称为Windows PowerShell，它于2016年8月18日通过PowerShell Core的推出而成为开源和跨平台。前者构建于 .NET Framework上，后者构建于 .NET Core上。</p><p>在PowerShell中，管理任务通常由<code>cmdlet</code>（发音为command-lets）执行，<strong>cmdlet是实现特定操作的专用 .NET 类</strong>。这些工作通过访问不同数据存储中的数据（如文件系统或注册表），这些数据存储通过提供程序提供给PowerShell 。第三方开发人员可以向PowerShell添加cmdlet和提供程序。自定义的脚本可以使用Cmdlet ，还可以打包成模块作为新的Cmdlet使用。</p><p>PowerShell提供对COM和WMI的完全访问，使管理员能够在本地和远程Windows系统以及WS-Management和CIM上执行管理任务，从而实现远程对Linux系统和网络设备的管理。PowerShell还提供了一个托管API，PowerShell运行时可以使用该API嵌入到其他应用程序中。然后，这些应用程序可以使用PowerShell功能来实现某些操作，包括通过图形界面公开的操作。Microsoft Exchange Server 2007 使用此功能将其管理功能公开为PowerShell指令和提供程序并实现作为PowerShell主机的图形管理工具，可通过调用必要的cmdlet来使用Exchange Sever 2007。其他Microsoft应用程序（包括Microsoft SQL Server 2008）也通过PowerShell cmdlet公开其管理界面。</p><p>PowerShell含有广泛的，基于控制台的自身帮助（类似于手册页在Unix外壳）通过键入<code>Get-Help</code>命令即可轻松获取使用方法。你可以通过<code>Update-Help</code> cmdlet 从Internet升级本地帮助内容，还能通过<code>Get-Help &lt;命令名&gt; -online</code>获取来自网络的帮助。</p><hr><blockquote><p>以上内容来自<a href="https://en.wikipedia.org/wiki/PowerShell#Background" target="_blank" rel="noopener">PowerShell - Wikipedia</a>，背景和开发人员设想部分为笔者翻译(翻译如有问题欢迎指出)，开发历程和简介由Google提供翻译服务，笔者进行了校对。</p></blockquote><hr><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><blockquote><p>了解更多请参考： <a href="https://en.wikipedia.org/w/index.php?title=PowerShell#Versions" target="_blank" rel="noopener">PowerShell - Wikipedia</a></p></blockquote><p>最初使用代号“Monad”，PowerShell于2003年9月首次在专业开发者大会上公开展示。所有主要版本仍然受支持，并且每个主要版本都具有与先前版本的向后兼容性。</p><h5 id="PowerShell-1-0"><a href="#PowerShell-1-0" class="headerlink" title="PowerShell 1.0"></a>PowerShell 1.0</h5><p>PowerShell 1.0于2006年11月发布，适用于Windows XP SP2，Windows Server 2003 SP1和Windows Vista。它还是Windows Server 2008的可选组件。</p><h5 id="PowerShell-2-0"><a href="#PowerShell-2-0" class="headerlink" title="PowerShell 2.0"></a>PowerShell 2.0</h5><p>PowerShell 2.0与Windows 7和Windows Server 2008 R2集成，适用于Windows XP Service Pack 3，Windows Server 2003 Service Pack 2和Windows Vista Service Pack 1. </p><p>PowerShell v2除了包含240多个新cmdlet之外，还包括对脚本语言和托管API的更改。</p><h5 id="PowerShell-3-0"><a href="#PowerShell-3-0" class="headerlink" title="PowerShell 3.0"></a>PowerShell 3.0</h5><p>PowerShell 3.0与Windows 8和Windows Server 2012集成在一起。Microsoft还为Windows 7 Service Pack 1，Windows Server 2008 Service Pack 1和Windows Server 2008 R2 Service Pack 1 提供了PowerShell 3.0 。</p><p>PowerShell 3.0是更大的软件包Windows Management Framework 3.0（WMF3）的一部分，它还包含支持远程处理的WinRM服务。Windows Management Framework 3.0的早期社区技术预览2（CTP 2）版本于2011年12月2日发布。 Windows Management Framework 3.0于2012年12月发布，并默认包含在Windows 8和Windows Server 2012中。</p><h5 id="PowerShell-4-0"><a href="#PowerShell-4-0" class="headerlink" title="PowerShell 4.0"></a>PowerShell 4.0</h5><p>PowerShell 4.0与Windows 8.1和Windows Server 2012 R2集成在一起。Microsoft还为Windows 7 SP1，Windows Server 2008 R2 SP1和Windows Server 2012提供了PowerShell 4.0。</p><h5 id="PowerShell-5-0"><a href="#PowerShell-5-0" class="headerlink" title="PowerShell 5.0"></a>PowerShell 5.0</h5><p>包含PowerShell 5.0的Windows Management Framework（WMF）5.0 RTM于2016年2月24日在发布严重错误的初始版本后重新发布到Web。主要功能包括OneGet PowerShell cmdlet，支持Chocolatey基于存储库的包管理，并将对交换机管理的支持扩展到第2层网络交换机。</p><h5 id="PowerShell-5-1"><a href="#PowerShell-5-1" class="headerlink" title="PowerShell 5.1"></a>PowerShell 5.1</h5><p>它与2016年8月2日的Windows 10 周年更新以及Windows Server 2016一起发布。PackageManagement现在支持代理，PSReadLine现在支持ViMode，并添加了两个新的cmdlet：Get-TimeZone和Set-TimeZone。LocalAccounts模块允许添加/删除本地用户帐户。 PowerShell 5.1的预览版已于2016年7月16日针对Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Server 2012和Windows Server 2012 R2 发布，并于2017年1月19日发布正式版。</p><p>PowerShell 5.1是第一个有两个版本的PowerShell，包括“桌面”和“核心”版本。“桌面”版本是在完整的 .NET Framework堆栈上运行的传统Windows PowerShell的延续。“Core”版本在 .NET Core上运行，并与Windows Server 2016 Nano Server捆绑在一起。为了减少占用空间，后者缺少一些功能，例如用于管理剪贴板的cmdlet或将计算机加入域，WMI版本1 cmdlet，事件日志cmdlet和配置文件。这是专为Windows制作的PowerShell的最终版本。</p><h5 id="PowerShell-6-0"><a href="#PowerShell-6-0" class="headerlink" title="PowerShell 6.0"></a>PowerShell 6.0</h5><p>PowerShell Core 6.0于2016年8月18日首次发布，当时微软公布了PowerShell Core并决定使该产品跨平台，独立于Windows，而且是免费和开源的。<br>它于2018年1月10日实现了Windows，macOS和Linux的普遍可用性。它有自己的支持生命周期，并遵循Windows 10引入的Microsoft生命周期策略：仅支持最新版本的PowerShell Core。微软希望每六个月为PowerShell Core 6.0发布一个次要版本。</p><p>此版本PowerShell中最重要的变化是扩展到其他平台。对于Windows管理员，此版本的PowerShell没有任何主要的新功能。在2018年1月11日的社区访谈中，PowerShell团队被要求列出将从Windows PowerShell 5.1迁移到PowerShell Core 6.0的Windows IT专业人员可能发生的十大最令人兴奋的事情。作为回应，微软的Angel Calvo只能说出两个：跨平台和开源(这两个就足够了)。</p><h6 id="目前Windows-10-上自带的最新版本是5-1"><a href="#目前Windows-10-上自带的最新版本是5-1" class="headerlink" title="目前Windows 10 上自带的最新版本是5.1"></a>目前Windows 10 上自带的最新版本是5.1</h6><p>[^1]:一种可以采用各种语言以及固定格式等实现、并能与其他 ActiveX 控件(可以理解为一种互联网插件)交互的脚本</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Powershell入门指南-一-·PowerShell及CLI发展&quot;&gt;&lt;a href=&quot;#Powershell入门指南-一-·PowerShell及CLI发展&quot; class=&quot;headerlink&quot; title=&quot;Powershell入门指南(一)·PowerShell及CLI发展&quot;&gt;&lt;/a&gt;Powershell入门指南(一)·PowerShell及CLI发展&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png&quot; alt=&quot;PowerShell&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://crepe.coding.me/Crepeblog/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>春节快乐</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/02/04/%E6%98%A5%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/02/04/春节快乐/</id>
    <published>2019-02-04T12:38:56.000Z</published>
    <updated>2019-02-11T12:59:58.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="春节快乐"><a href="#春节快乐" class="headerlink" title="春节快乐"></a>春节快乐</h2><p>祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看</p><a id="more"></a><h2 id="献上笔者绘制的Peppa-Pig-社会猪佩奇"><a href="#献上笔者绘制的Peppa-Pig-社会猪佩奇" class="headerlink" title="献上笔者绘制的Peppa Pig(社会猪佩奇)"></a>献上笔者绘制的Peppa Pig(社会猪佩奇)</h2><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/SpF.png" alt="Happy New Year!"></p><h2 id="送上猪年祝福语"><a href="#送上猪年祝福语" class="headerlink" title="送上猪年祝福语"></a>送上猪年祝福语</h2><ul><li>春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。</li><li>朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！</li><li>猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！</li><li>除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！</li><li>春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。</li><li>猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！</li><li>一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！</li><li>春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！</li></ul><h3 id="绘制佩奇使用的是PS的钢笔"><a href="#绘制佩奇使用的是PS的钢笔" class="headerlink" title="绘制佩奇使用的是PS的钢笔"></a>绘制佩奇使用的是PS的钢笔</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/PeppaPig1.jpg" alt="Happy New Year!"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;春节快乐&quot;&gt;&lt;a href=&quot;#春节快乐&quot; class=&quot;headerlink&quot; title=&quot;春节快乐&quot;&gt;&lt;/a&gt;春节快乐&lt;/h2&gt;&lt;p&gt;祝各位春节快乐,新的一年大家也要继续努力鸭!
笔者还准备了礼物送给大家，点击下面的阅读全文查看&lt;/p&gt;
    
    </summary>
    
    
      <category term="节日祝福" scheme="https://crepe.coding.me/Crepeblog/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="春节" scheme="https://crepe.coding.me/Crepeblog/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>HTML (一)</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/01/25/HTML%20(%E4%B8%80)/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/01/25/HTML (一)/</id>
    <published>2019-01-25T13:36:08.000Z</published>
    <updated>2019-02-11T12:59:58.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 指超文本标记语言</p><blockquote><p>HTML 是通向 WEB 技术世界的钥匙。</p></blockquote><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。<br>现如今，HTML已经是程序员必须掌握的一项基本功。</p><h2 id="HTML发展史"><a href="#HTML发展史" class="headerlink" title="HTML发展史"></a>HTML发展史</h2><p>HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，<br>1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，<br>后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。</p><blockquote><p>*HTML 2.0——1995年11月，RFC 1866发布<br>*HTML 3.2——1997年1月14日，W3C发布推荐标准<br>*HTML 4.0——1997年12月18日，W3C发布推荐标准<br>*HTML 4.01——1999年12月24日，W3C发布推荐标准<br>*HTML 5——2014年10月28日，W3C发布推荐标准</p></blockquote><h2 id="HTML5编辑规范"><a href="#HTML5编辑规范" class="headerlink" title="HTML5编辑规范"></a>HTML5编辑规范</h2><ol><li>文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg</li><li>浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车</li><li>标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。</li><li>必须使用半角而不是全角字符</li><li>HTML注释<code>&lt;!--注释内容--&gt;</code>的内容不给予显示。</li></ol><h2 id="这是笔者写的较为详细的一个入门页面"><a href="#这是笔者写的较为详细的一个入门页面" class="headerlink" title="这是笔者写的较为详细的一个入门页面"></a>这是笔者写的较为详细的一个入门页面</h2><p><a href="https://lollipopnougat.github.io/website-calculator/html/HTML1.html" target="_blank" rel="noopener">HTML入门·一</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;p&gt;HTML 指超文本标记语言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 是通向 WEB 技术世界的钥匙。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://crepe.coding.me/Crepeblog/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell (一)</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/01/17/PowerShell%20(%E4%B8%80)/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/01/17/PowerShell (一)/</id>
    <published>2019-01-17T11:48:41.000Z</published>
    <updated>2019-02-11T12:59:58.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h2><p>PowerShell 是一种命令行外壳程序和脚本环境，<br>使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。</p><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png" alt="PowerShell"></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，<br>PowerShell需要.NET环境的支持，借助 <strong>.NET Framework</strong>平台强大的类库，几乎让一切都成为可能。<br>微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。</p><h2 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h2><p>Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。<br>PowerShell以 <strong>.NET Framework</strong>为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。<br>PowerShell推出了一个功能强大的命令叫做<code>cmdlet</code>,所有的cmdlet命令都遵循动词-名词这样语法结构。<br>如<code>Get-Command</code>, <code>Get-Process</code>等，<br>即使从来没有接触过PowerShell，也很容易能够明白命令的作用。<br>如<code>Get-Process</code>命令的意思就是获取所有的进程。</p><h2 id="新的脚本语言"><a href="#新的脚本语言" class="headerlink" title="新的脚本语言"></a>新的脚本语言</h2><p>由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：<br>Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。<br>该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。</p><ol><li><p>PS1文件<br>一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，<br>每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。</p></li><li><p>执行权限<br>为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（<code>Restricted</code>），<br>意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略：</p><blockquote><ul><li><code>Get-ExecutionPolicy</code>你可以选择使用的执行策略有：</li><li><code>Restricted</code> -脚本不能运行。 </li><li><code>RemoteSigned</code> - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 </li><li><code>AllSigned</code> – 仅当脚本由受信任的发布者签名才能运行。 </li><li><code>Unrestricted</code> –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</li></ul></blockquote></li></ol><p>你可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>运行脚本<br>如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，<br>在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，<br>但这个古老的方法现在却不能适用于PowerShell可执行脚本了。<br>如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，<br>例如，假设你要运行一个名为a.ps1的脚本，你可以键入：<br><code>C:\Scripts\aps1</code><br>最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，<br>那么你可以直接在命令提示符后键入脚本文件名即可运行，如：<br><code>.\a.ps1</code> 注意前面需要加上<code>.\</code>，这和Linux下执行Shell脚本的方法如出一辙。</p></li><li><p>管道<br>管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（<code>|</code>）连接即可。<br>为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，<br>可以使用<code>Get-Process</code> cmdlet命令获得进程列表，但默认情况下列表不会排序，<br>如果将这个cmdlet命令的输出用管道输送给<code>Sort-Object ID</code>命令，进程列表将会按进程ID号进行排序，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID</span><br></pre></td></tr></table></figure></li><li><p>变量<br>虽然可以使用管道将一个命令的输出输送给另一个命令，<br>但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，<br>但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。<br>人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，<br>例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：<br><code>$a = Get-Process</code><br>在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，<br>例如，键入$a便可在屏幕上打印变量的内容。<br>你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，<br>例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = (<span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID)</span><br></pre></td></tr></table></figure></li><li><p>@符号<br>通过使用@符号，你可以将列表内容转换成一个数组，<br>例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：<br><code>$procs = @{name=&quot;explorer&quot;,&quot;svchost&quot;}</code><br>使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，<br>例如，下面的代码将在我前面定义的变量上运行<code>Get-Process</code> cmdlet命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> @procsWindows</span><br></pre></td></tr></table></figure></li></ol><p>将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的<code>@</code>符号，而不是常见的<code>$</code>符号。</p><ol start="7"><li><p>Split<br>Split操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This is a test"</span> -split <span class="string">" "</span></span><br></pre></td></tr></table></figure><p>拆分后的结果如下：<br><code>This is a test</code></p></li><li><p>Join<br>就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，<br>例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Brien"</span>,<span class="string">"Posey"</span> -join <span class="string">" "</span></span><br></pre></td></tr></table></figure><p>命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。</p></li><li><p>断点<br>运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，<br>保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。<br>插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">New-PSBreakpoint -Script C:\Scripts\a.ps1 -Line <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：</span></span><br><span class="line">New-PSBreakpoint -Script C:\scripts\a.ps1 -variables a </span><br><span class="line"><span class="comment">#注意，在变量名后并没有包括美元符号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。</span></span><br></pre></td></tr></table></figure></li><li><p>Step<br>调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用<code>Step-Into</code> cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用<code>Step-Out</code> cmdlet命令即可，<br>但需要注意的是，使用<code>Step-Out</code> cmdlet命令后，断点仍然有效。<br>顺便说一句，如果你的脚本使用了函数，你可能对<code>Step-Out</code> cmdlet更感兴趣，<code>Step-Out</code> 的工作方式和<code>Step-Into</code> 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。</p></li></ol><h3 id="因此PowerShell实际是一门独立的脚本语言了"><a href="#因此PowerShell实际是一门独立的脚本语言了" class="headerlink" title="因此PowerShell实际是一门独立的脚本语言了"></a>因此PowerShell实际是一门独立的脚本语言了</h3><h2 id="PowerShell能干什么？"><a href="#PowerShell能干什么？" class="headerlink" title="PowerShell能干什么？"></a>PowerShell能干什么？</h2><h3 id="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"><a href="#PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，" class="headerlink" title="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"></a>PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，</h3><p>为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。</p><p>PowerShell能做下面这些事:</p><blockquote><p>.NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint,<br> Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS,<br> Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications.<br> 基本上所有的微软产品都提供PowerShell接口。</p></blockquote><h4 id="1、管理进程"><a href="#1、管理进程" class="headerlink" title="1、管理进程"></a>1、管理进程</h4><p>前面已经提过管理系统进程的命令，管理进程常用命令就是<code>get-process</code>和<code>stop-process</code>，<code>get-process</code>获取进程之后可以直接用管道发送给<code>stop-process</code>结束进程。<br>比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-process</span> -Name notepad | <span class="built_in">stop-process</span></span><br></pre></td></tr></table></figure><h4 id="2、处理文件和文件夹"><a href="#2、处理文件和文件夹" class="headerlink" title="2、处理文件和文件夹"></a>2、处理文件和文件夹</h4><p>PowerShell使用<code>Get-ChildItem</code>获取文件夹中直接包含的所有项，<br>它有系统内置别名<code>dir</code>和<code>ls</code>，使用CMD和BASH的用户均可以轻松上手。<br>如果想查看<code>C:</code>中的文件夹和文件，直接使用<code>dir c:</code>，PowerShell立刻就会列出<code>C:</code>中的文件和文件夹。<br>其它处理文件和文件夹的命令有<code>Copy-Item</code>、<code>New-Item</code>、<code>Remove-Item</code>等，<br>具体用法可以使用<code>get-help</code>然后跟命令名称即可查询。</p><h4 id="3、处理系统服务"><a href="#3、处理系统服务" class="headerlink" title="3、处理系统服务"></a>3、处理系统服务</h4><p>可以像管理进程一样管理系统服务，</p><ul><li><code>Get-Service</code>命令获取服务列表，</li><li><code>Stop-Service</code>命令停止服务，</li><li><code>Start-Service</code>命令启动服务，</li><li><code>Suspend-Service</code>命令挂起服务，</li><li><code>Restart-Service</code>命令重启服务，</li><li><code>Set-Service</code>服务设置服务属性。<br>如果想一次性启动已经停止的服务，可以使用以下命令：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> | <span class="built_in">where-object</span> &#123;<span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">"Stopped"</span>&#125; -exclude</span><br></pre></td></tr></table></figure></li></ul><p><strong>下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。</strong><br><code>wisvc | start-service</code></p><h4 id="4、处理注册表"><a href="#4、处理注册表" class="headerlink" title="4、处理注册表"></a>4、处理注册表</h4><p>PowerShell可以非常方便的处理注册表项目，<br>与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，<br>这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。<br>由于注册表对系统<strong>非常重要</strong>，<strong>错误处理注册表也许会导致系统出问题</strong>，处理注册表，特别是删除注册表项目要<strong>非常小心</strong>，最好能在处理注册表项目之前先<strong>备份</strong>要处理的项目。<strong>没有管理员权限也能处理部分注册表项目</strong>，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。</p><h4 id="5、处理其它任务"><a href="#5、处理其它任务" class="headerlink" title="5、处理其它任务"></a>5、处理其它任务</h4><p>PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。</p><h4 id="6、编写脚本程序"><a href="#6、编写脚本程序" class="headerlink" title="6、编写脚本程序"></a>6、编写脚本程序</h4><p>借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，<br>PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，<br>来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，<br>有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。</p><h2 id="一个有趣的例子"><a href="#一个有趣的例子" class="headerlink" title="一个有趣的例子"></a>一个有趣的例子</h2><p>这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。<br>有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的excel com对象</span></span><br><span class="line"><span class="variable">$objExcel</span> = <span class="built_in">New-Object</span> -comobject Excel.Application</span><br><span class="line"><span class="variable">$objExcel</span>.Visible = <span class="literal">$True</span></span><br><span class="line"><span class="variable">$objWorkbook</span> = <span class="variable">$objExcel</span>.Workbooks.Add()</span><br><span class="line"><span class="variable">$objWorksheet</span> = <span class="variable">$objWorkbook</span>.Worksheets.Item(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把信息写入excel</span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span></span><br><span class="line"><span class="variable">$first10</span> = (ps | sort ws -Descending | select -first <span class="number">10</span>)</span><br><span class="line"><span class="variable">$first10</span> | <span class="keyword">foreach</span> -Process &#123;<span class="variable">$i</span>++; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">1</span>) = <span class="variable">$_</span>.name; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">2</span>) = <span class="variable">$_</span>.ws&#125;</span><br><span class="line"><span class="variable">$otherMem</span> = (ps | measure ws -s).Sum - (<span class="variable">$first10</span> | measure ws -s).Sum</span><br><span class="line"><span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">1</span>) = <span class="string">"Others"</span>; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">2</span>) = <span class="variable">$otherMem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画饼图</span></span><br><span class="line"><span class="variable">$objCharts</span> = <span class="variable">$objWorksheet</span>.ChartObjects()</span><br><span class="line"><span class="variable">$objChart</span> = <span class="variable">$objCharts</span>.Add(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.SetSourceData(<span class="variable">$objWorksheet</span>.range(<span class="string">"A1:B11"</span>), <span class="number">2</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.ChartType = <span class="number">70</span></span><br><span class="line"><span class="variable">$objChart</span>.Chart.ApplyDataLabels(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停</span></span><br><span class="line">pause</span><br><span class="line"><span class="variable">$objExcel</span>.Quit()</span><br><span class="line"><span class="variable">$objExcel</span> = <span class="literal">$null</span></span><br><span class="line">[GC]::Collect()</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果:"></a>执行结果:</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/screenshot.png" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Powershell&quot;&gt;&lt;a href=&quot;#Powershell&quot; class=&quot;headerlink&quot; title=&quot;Powershell&quot;&gt;&lt;/a&gt;Powershell&lt;/h2&gt;&lt;p&gt;PowerShell 是一种命令行外壳程序和脚本环境，&lt;br&gt;使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png&quot; alt=&quot;PowerShell&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://crepe.coding.me/Crepeblog/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>元旦快乐</title>
    <link href="https://crepe.coding.me/Crepeblog/2019/01/01/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/"/>
    <id>https://crepe.coding.me/Crepeblog/2019/01/01/元旦快乐/</id>
    <published>2018-12-31T16:12:12.000Z</published>
    <updated>2019-02-11T12:59:58.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019元旦快乐"><a href="#2019元旦快乐" class="headerlink" title="2019元旦快乐"></a>2019元旦快乐</h2><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/newyear.gif" alt="Happy New Year!"></p><a id="more"></a><h4 id="相逢是首悠扬的歌，相识是杯醇香的酒，"><a href="#相逢是首悠扬的歌，相识是杯醇香的酒，" class="headerlink" title="相逢是首悠扬的歌，相识是杯醇香的酒，"></a>相逢是首悠扬的歌，相识是杯醇香的酒，</h4><h4 id="相处是那南飞的雁，相知是根古老的藤。"><a href="#相处是那南飞的雁，相知是根古老的藤。" class="headerlink" title="相处是那南飞的雁，相知是根古老的藤。"></a>相处是那南飞的雁，相知是根古老的藤。</h4><h4 id="健康是最佳的礼物，知足是最大的财富，"><a href="#健康是最佳的礼物，知足是最大的财富，" class="headerlink" title="健康是最佳的礼物，知足是最大的财富，"></a>健康是最佳的礼物，知足是最大的财富，</h4><h4 id="信心是最可贵的品德，关心是最真挚的问候，"><a href="#信心是最可贵的品德，关心是最真挚的问候，" class="headerlink" title="信心是最可贵的品德，关心是最真挚的问候，"></a>信心是最可贵的品德，关心是最真挚的问候，</h4><h4 id="牵挂是最无私的思念，祝福是最美好的话语！"><a href="#牵挂是最无私的思念，祝福是最美好的话语！" class="headerlink" title="牵挂是最无私的思念，祝福是最美好的话语！"></a>牵挂是最无私的思念，祝福是最美好的话语！</h4><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/HappyNewYear.jpg" alt="Happy New Year!"></p><h1 id="在此献上最美好的祝福"><a href="#在此献上最美好的祝福" class="headerlink" title="在此献上最美好的祝福"></a>在此献上最美好的祝福</h1><h2 id="祝各位朋友们2019年新年快乐！平安幸福！"><a href="#祝各位朋友们2019年新年快乐！平安幸福！" class="headerlink" title="祝各位朋友们2019年新年快乐！平安幸福！"></a>祝各位朋友们2019年新年快乐！平安幸福！</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2019元旦快乐&quot;&gt;&lt;a href=&quot;#2019元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;2019元旦快乐&quot;&gt;&lt;/a&gt;2019元旦快乐&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/newyear.gif&quot; alt=&quot;Happy New Year!&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="节日祝福" scheme="https://crepe.coding.me/Crepeblog/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="元旦" scheme="https://crepe.coding.me/Crepeblog/tags/%E5%85%83%E6%97%A6/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计</title>
    <link href="https://crepe.coding.me/Crepeblog/2018/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://crepe.coding.me/Crepeblog/2018/12/30/面向对象的程序设计/</id>
    <published>2018-12-30T07:06:15.000Z</published>
    <updated>2019-02-11T13:00:38.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。<br>对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据<strong>封装</strong>其中，以提高软件的<strong>重用性</strong>、<strong>灵活性</strong>和<strong>扩展性</strong>。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，<br>传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。<br>目前已经被证实的是，面向对象程序设计推广了程序的<strong>灵活性</strong>和<strong>可维护性</strong>，并且在大型项目设计中广为应用。<br>此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>面向对象是在结构化设计方法出现很多问题的情况下应运而生的。</p><p>结构化设计方法求解问题的基本策略是从功能的角度审视问题域。<br>它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。<br>在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。<br>面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。</p><h4 id="1-审视问题域的视角"><a href="#1-审视问题域的视角" class="headerlink" title="1. 审视问题域的视角"></a>1. 审视问题域的视角</h4><blockquote><p>在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。<br>通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。<br>结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。</p></blockquote><h4 id="2-抽象级别"><a href="#2-抽象级别" class="headerlink" title="2. 抽象级别"></a>2. 抽象级别</h4><blockquote><p>抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。</p></blockquote><h4 id="3-封装体"><a href="#3-封装体" class="headerlink" title="3. 封装体"></a>3. 封装体</h4><blockquote><p>封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。</p></blockquote><h4 id="4-可重用性"><a href="#4-可重用性" class="headerlink" title="4. 可重用性"></a>4. 可重用性</h4><blockquote><p>可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。</p></blockquote><p>上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。</p><p>面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。<br>在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地<em>适应了潮流</em>。面向对象程序设计的思想也使<strong>事件处理式</strong>的程序设计更加广泛被应用</p><h2 id="抽象的示例"><a href="#抽象的示例" class="headerlink" title="抽象的示例"></a>抽象的示例</h2><p>假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，<br>首先想到的是开一个结构体，然后定义几个变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sheep</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sheep Jeff; <span class="comment">//定义一只叫Jeff的羊</span></span><br></pre></td></tr></table></figure><p>很容易，现在Jeff要跑，怎么办？<br>于是就用一个run函数，把Jeff作为一个参数传递来实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Sheep sheep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(Jeff);</span><br></pre></td></tr></table></figure><p>也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？<br>再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？</p><p>这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；<br>这样，所有的羊都有了一种叫跑步的方法，就方便多了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="built_in">string</span> method=<span class="string">"default"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mie</span><span class="params">()</span></span>;<span class="comment">//咩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height,weight;</span><br><span class="line">&#125;;<span class="comment">//定义一个Sheep类</span></span><br><span class="line"></span><br><span class="line">Sheep Jeff;</span><br><span class="line">Jeff.run(); <span class="comment">//Jeff使用默认的方法跑步</span></span><br><span class="line"></span><br><span class="line">Sheep YangDaXia;</span><br><span class="line">YangDaXia.run(<span class="string">"onFoot"</span>); <span class="comment">//羊大侠站着跑</span></span><br><span class="line"></span><br><span class="line">Sheep XiYangYang;</span><br><span class="line">XiYangYang.run(<span class="string">"shoes"</span>); <span class="comment">//喜羊羊穿鞋跑</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面向对象的程序设计&quot;&gt;&lt;a href=&quot;#面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;面向对象的程序设计&quot;&gt;&lt;/a&gt;面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。&lt;br&gt;对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据&lt;strong&gt;封装&lt;/strong&gt;其中，以提高软件的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;扩展性&lt;/strong&gt;。
面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，&lt;br&gt;传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面向对象" scheme="https://crepe.coding.me/Crepeblog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="C/C++" scheme="https://crepe.coding.me/Crepeblog/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>The first one</title>
    <link href="https://crepe.coding.me/Crepeblog/2018/12/30/The-first-one/"/>
    <id>https://crepe.coding.me/Crepeblog/2018/12/30/The-first-one/</id>
    <published>2018-12-30T03:44:32.000Z</published>
    <updated>2019-02-11T12:59:58.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试用页面"><a href="#测试用页面" class="headerlink" title="测试用页面"></a>测试用页面</h2><a id="more"></a><p>第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1]<br>[^1]: 这是脚注</p><h1 id="这是1级标题"><a href="#这是1级标题" class="headerlink" title="这是1级标题"></a>这是1级标题</h1><p><em>这是斜体</em><br><strong>这是加粗</strong><br><strong><em>这是斜体加粗</em></strong></p><p><del>这是删除</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello,world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这是代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这是2级标题"><a href="#这是2级标题" class="headerlink" title="这是2级标题"></a>这是2级标题</h2><p><code>这是代码块</code></p><h3 id="这是3级标题"><a href="#这是3级标题" class="headerlink" title="这是3级标题"></a>这是3级标题</h3><blockquote><p>这是引述</p><blockquote><p>这是引述嵌套</p></blockquote></blockquote><p><img src="https://www.baidu.com/img/dong_418ce2c6c5171fb4cb0d4d1edb4fab68.gif" alt="这是图片"> </p><hr><h4 id="这是4级标题"><a href="#这是4级标题" class="headerlink" title="这是4级标题"></a>这是4级标题</h4><p><a href="http://www.baidu.com" target="_blank" rel="noopener">这是百度一下</a></p><p>-[x] 选项一<br>-[ ] 选项二<br>-[ ] 选项三</p><hr><h5 id="这是5级标题"><a href="#这是5级标题" class="headerlink" title="这是5级标题"></a>这是5级标题</h5><ul><li>这是无序列表</li><li>这是无序列表</li><li>这是无序列表</li></ul><ol><li>这是有序列表</li><li>这是有序列表</li><li>这是有序列表</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;测试用页面&quot;&gt;&lt;a href=&quot;#测试用页面&quot; class=&quot;headerlink&quot; title=&quot;测试用页面&quot;&gt;&lt;/a&gt;测试用页面&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
